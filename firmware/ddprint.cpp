/*
* This file is part of ddprint - a direct drive 3D printer firmware.
* 
* Copyright 2015 erwin.rieger@ibrieger.de
* 
* ddprint is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
* 
* ddprint is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with ddprint.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
 * Todo jennyprinter port:
 * * fully remove fastio.h
 * * swapdevice: add sanity test sectorsize != 512 bytes?
 * * usb: some flash sticks seem to hang at getReady cmd (add timeout / testUnitReadyRetry)
 * * cleanup task info stuff
 */

#include <Arduino.h>

#include <limits.h>

#include "Protothread.h"
#include "crc16.h"

#include "ddprint.h"
#include "serialport.h"
#include "temperature.h"
#include "ddtemp.h"
#include "swapdev.h"
#include "filsensor.h"
#include "ddserial.h"
#include "ddcommands.h"
#include "ddlcd.h"
#include "stepper.h"
#include "hostsettings.h"

#include "uz.h"

//The ASCII buffer for recieving from SD:
#define SD_BUFFER_SIZE 512

// Macro to read scalar types from a buffer
#define FromBuf(typ, adr) ( * ((typ *)(adr)))

#define X_SW_ENDSTOP_PRESSED ((current_pos_steps[X_AXIS] < 0) || (current_pos_steps[X_AXIS] > (int32_t)hostSettings.buildVolX))
#define Y_SW_ENDSTOP_PRESSED ((current_pos_steps[Y_AXIS] < 0) || (current_pos_steps[Y_AXIS] > (int32_t)hostSettings.buildVolY))
#define Z_SW_ENDSTOP_PRESSED ((current_pos_steps[Z_AXIS] < 0) || (current_pos_steps[Z_AXIS] > (int32_t)hostSettings.buildVolZ))

// debug

enum LoopTasks { TaskIdle, TaskTempControl, TaskHeater, TaskFilSensor, TaskUsbInput, TaskUsbOutput, TaskSwapDev, TaskFillBuffer, TaskSum};

static struct TaskTiming taskTiming[9] = { 
    { 0, 0, 0, 0 },         // Idle time between loop() calles
    { 0, 0, 0, 0 },         // Temperature measurement
    { 0, 0, 0, 0 },         // Heater temperature control
    { 0, 0, 0, 0 },         // Filament sensor readings (flowrate measurement)
    { 0, 0, 0, 0 },         // USB input
    { 0, 0, 0, 0 },         // USB output
    { 0, 0, 0, 0 },         // Mass storage IO 
    { 0, 0, 0, 0 },         // Read *swapdev* and fill *stepbuffer*
    { 0, 0, 0, 0 },         // Summary of all these tasks
};



/////////////////////////////////////////////////////////////////////////////////////
#if defined(USEExtrusionRateTable)

uint16_t extrusionLimitBaseTemp = 170;

//
// Limit extrusion rate by the hotend temperature. This is the initial table
// with no real limitations. The pertinent values are downloaded by the host
// software before print.
//
// Generated by snippets/genTempTable.py
uint16_t tempExtrusionRateTable[NExtrusionLimit] = {
    /* Temp: 170.000000, max flowrate: 0.1 mm³/s, max espeed: 0.0 mm/s, steps/s: 5, steprate: 170587 us, timervalue: */ 65535,
    /* Temp: 171.000000, max flowrate: 0.5 mm³/s, max espeed: 0.2 mm/s, steps/s: 29, steprate: 34117 us, timervalue: */ 65535,
    /* Temp: 172.000000, max flowrate: 0.9 mm³/s, max espeed: 0.4 mm/s, steps/s: 52, steprate: 18954 us, timervalue: */ 37908,
    /* Temp: 173.000000, max flowrate: 1.3 mm³/s, max espeed: 0.5 mm/s, steps/s: 76, steprate: 13122 us, timervalue: */ 26244,
    /* Temp: 174.000000, max flowrate: 1.7 mm³/s, max espeed: 0.7 mm/s, steps/s: 99, steprate: 10034 us, timervalue: */ 20069,
    /* Temp: 175.000000, max flowrate: 2.1 mm³/s, max espeed: 0.9 mm/s, steps/s: 123, steprate: 8123 us, timervalue: */ 16246,
    /* Temp: 176.000000, max flowrate: 2.5 mm³/s, max espeed: 1.0 mm/s, steps/s: 146, steprate: 6823 us, timervalue: */ 13646,
    /* Temp: 177.000000, max flowrate: 2.9 mm³/s, max espeed: 1.2 mm/s, steps/s: 170, steprate: 5882 us, timervalue: */ 11764,
    /* Temp: 178.000000, max flowrate: 3.3 mm³/s, max espeed: 1.4 mm/s, steps/s: 193, steprate: 5169 us, timervalue: */ 10338,
    /* Temp: 179.000000, max flowrate: 3.7 mm³/s, max espeed: 1.5 mm/s, steps/s: 216, steprate: 4610 us, timervalue: */ 9220,
    /* Temp: 180.000000, max flowrate: 4.1 mm³/s, max espeed: 1.7 mm/s, steps/s: 240, steprate: 4160 us, timervalue: */ 8321,
    /* Temp: 181.000000, max flowrate: 4.5 mm³/s, max espeed: 1.9 mm/s, steps/s: 263, steprate: 3790 us, timervalue: */ 7581,
    /* Temp: 182.000000, max flowrate: 4.9 mm³/s, max espeed: 2.0 mm/s, steps/s: 287, steprate: 3481 us, timervalue: */ 6962,
    /* Temp: 183.000000, max flowrate: 5.3 mm³/s, max espeed: 2.2 mm/s, steps/s: 310, steprate: 3218 us, timervalue: */ 6437,
    /* Temp: 184.000000, max flowrate: 5.7 mm³/s, max espeed: 2.4 mm/s, steps/s: 334, steprate: 2992 us, timervalue: */ 5985,
    /* Temp: 185.000000, max flowrate: 6.1 mm³/s, max espeed: 2.5 mm/s, steps/s: 357, steprate: 2796 us, timervalue: */ 5593,
    /* Temp: 186.000000, max flowrate: 6.5 mm³/s, max espeed: 2.7 mm/s, steps/s: 381, steprate: 2624 us, timervalue: */ 5248,
    /* Temp: 187.000000, max flowrate: 6.9 mm³/s, max espeed: 2.9 mm/s, steps/s: 404, steprate: 2472 us, timervalue: */ 4944,
    /* Temp: 188.000000, max flowrate: 7.3 mm³/s, max espeed: 3.0 mm/s, steps/s: 427, steprate: 2336 us, timervalue: */ 4673,
    /* Temp: 189.000000, max flowrate: 7.7 mm³/s, max espeed: 3.2 mm/s, steps/s: 451, steprate: 2215 us, timervalue: */ 4430,
    /* Temp: 190.000000, max flowrate: 8.1 mm³/s, max espeed: 3.4 mm/s, steps/s: 474, steprate: 2106 us, timervalue: */ 4212,
    /* Temp: 191.000000, max flowrate: 8.5 mm³/s, max espeed: 3.5 mm/s, steps/s: 498, steprate: 2006 us, timervalue: */ 4013,
    /* Temp: 192.000000, max flowrate: 8.9 mm³/s, max espeed: 3.7 mm/s, steps/s: 521, steprate: 1916 us, timervalue: */ 3833,
    /* Temp: 193.000000, max flowrate: 9.3 mm³/s, max espeed: 3.9 mm/s, steps/s: 545, steprate: 1834 us, timervalue: */ 3668,
    /* Temp: 194.000000, max flowrate: 9.7 mm³/s, max espeed: 4.0 mm/s, steps/s: 568, steprate: 1758 us, timervalue: */ 3517,
    /* Temp: 195.000000, max flowrate: 10.1 mm³/s, max espeed: 4.2 mm/s, steps/s: 592, steprate: 1688 us, timervalue: */ 3377,
    /* Temp: 196.000000, max flowrate: 10.5 mm³/s, max espeed: 4.4 mm/s, steps/s: 615, steprate: 1624 us, timervalue: */ 3249,
    /* Temp: 197.000000, max flowrate: 10.9 mm³/s, max espeed: 4.5 mm/s, steps/s: 638, steprate: 1565 us, timervalue: */ 3130,
    /* Temp: 198.000000, max flowrate: 11.3 mm³/s, max espeed: 4.7 mm/s, steps/s: 662, steprate: 1509 us, timervalue: */ 3019,
    /* Temp: 199.000000, max flowrate: 11.7 mm³/s, max espeed: 4.9 mm/s, steps/s: 685, steprate: 1458 us, timervalue: */ 2916,
    /* Temp: 200.000000, max flowrate: 12.1 mm³/s, max espeed: 5.0 mm/s, steps/s: 709, steprate: 1409 us, timervalue: */ 2819,
    /* Temp: 201.000000, max flowrate: 12.5 mm³/s, max espeed: 5.2 mm/s, steps/s: 732, steprate: 1364 us, timervalue: */ 2729,
    /* Temp: 202.000000, max flowrate: 12.9 mm³/s, max espeed: 5.4 mm/s, steps/s: 756, steprate: 1322 us, timervalue: */ 2644,
    /* Temp: 203.000000, max flowrate: 13.3 mm³/s, max espeed: 5.5 mm/s, steps/s: 779, steprate: 1282 us, timervalue: */ 2565,
    /* Temp: 204.000000, max flowrate: 13.7 mm³/s, max espeed: 5.7 mm/s, steps/s: 803, steprate: 1245 us, timervalue: */ 2490,
    /* Temp: 205.000000, max flowrate: 14.1 mm³/s, max espeed: 5.9 mm/s, steps/s: 826, steprate: 1209 us, timervalue: */ 2419,
    /* Temp: 206.000000, max flowrate: 14.5 mm³/s, max espeed: 6.0 mm/s, steps/s: 850, steprate: 1176 us, timervalue: */ 2352,
    /* Temp: 207.000000, max flowrate: 14.9 mm³/s, max espeed: 6.2 mm/s, steps/s: 873, steprate: 1144 us, timervalue: */ 2289,
    /* Temp: 208.000000, max flowrate: 15.3 mm³/s, max espeed: 6.4 mm/s, steps/s: 896, steprate: 1114 us, timervalue: */ 2229,
    /* Temp: 209.000000, max flowrate: 15.7 mm³/s, max espeed: 6.5 mm/s, steps/s: 920, steprate: 1086 us, timervalue: */ 2173,
    /* Temp: 210.000000, max flowrate: 16.1 mm³/s, max espeed: 6.7 mm/s, steps/s: 943, steprate: 1059 us, timervalue: */ 2119,
    /* Temp: 211.000000, max flowrate: 16.5 mm³/s, max espeed: 6.9 mm/s, steps/s: 967, steprate: 1033 us, timervalue: */ 2067,
    /* Temp: 212.000000, max flowrate: 16.9 mm³/s, max espeed: 7.0 mm/s, steps/s: 990, steprate: 1009 us, timervalue: */ 2018,
    /* Temp: 213.000000, max flowrate: 17.3 mm³/s, max espeed: 7.2 mm/s, steps/s: 1014, steprate: 986 us, timervalue: */ 1972,
    /* Temp: 214.000000, max flowrate: 17.7 mm³/s, max espeed: 7.4 mm/s, steps/s: 1037, steprate: 963 us, timervalue: */ 1927,
    /* Temp: 215.000000, max flowrate: 18.1 mm³/s, max espeed: 7.5 mm/s, steps/s: 1061, steprate: 942 us, timervalue: */ 1884,
    /* Temp: 216.000000, max flowrate: 18.5 mm³/s, max espeed: 7.7 mm/s, steps/s: 1084, steprate: 922 us, timervalue: */ 1844,
    /* Temp: 217.000000, max flowrate: 18.9 mm³/s, max espeed: 7.9 mm/s, steps/s: 1107, steprate: 902 us, timervalue: */ 1805,
    /* Temp: 218.000000, max flowrate: 19.3 mm³/s, max espeed: 8.0 mm/s, steps/s: 1131, steprate: 883 us, timervalue: */ 1767,
    /* Temp: 219.000000, max flowrate: 19.7 mm³/s, max espeed: 8.2 mm/s, steps/s: 1154, steprate: 865 us, timervalue: */ 1731,
    /* Temp: 220.000000, max flowrate: 20.1 mm³/s, max espeed: 8.4 mm/s, steps/s: 1178, steprate: 848 us, timervalue: */ 1697,
    /* Temp: 221.000000, max flowrate: 20.5 mm³/s, max espeed: 8.5 mm/s, steps/s: 1201, steprate: 832 us, timervalue: */ 1664,
    /* Temp: 222.000000, max flowrate: 20.9 mm³/s, max espeed: 8.7 mm/s, steps/s: 1225, steprate: 816 us, timervalue: */ 1632,
    /* Temp: 223.000000, max flowrate: 21.3 mm³/s, max espeed: 8.9 mm/s, steps/s: 1248, steprate: 800 us, timervalue: */ 1601,
    /* Temp: 224.000000, max flowrate: 21.7 mm³/s, max espeed: 9.0 mm/s, steps/s: 1272, steprate: 786 us, timervalue: */ 1572,
    /* Temp: 225.000000, max flowrate: 22.1 mm³/s, max espeed: 9.2 mm/s, steps/s: 1295, steprate: 771 us, timervalue: */ 1543,
    /* Temp: 226.000000, max flowrate: 22.5 mm³/s, max espeed: 9.4 mm/s, steps/s: 1318, steprate: 758 us, timervalue: */ 1516,
    /* Temp: 227.000000, max flowrate: 22.9 mm³/s, max espeed: 9.5 mm/s, steps/s: 1342, steprate: 744 us, timervalue: */ 1489,
    /* Temp: 228.000000, max flowrate: 23.3 mm³/s, max espeed: 9.7 mm/s, steps/s: 1365, steprate: 732 us, timervalue: */ 1464,
    /* Temp: 229.000000, max flowrate: 23.7 mm³/s, max espeed: 9.9 mm/s, steps/s: 1389, steprate: 719 us, timervalue: */ 1439,
    /* Temp: 230.000000, max flowrate: 24.1 mm³/s, max espeed: 10.0 mm/s, steps/s: 1412, steprate: 707 us, timervalue: */ 1415,
    /* Temp: 231.000000, max flowrate: 24.5 mm³/s, max espeed: 10.2 mm/s, steps/s: 1436, steprate: 696 us, timervalue: */ 1392,
    /* Temp: 232.000000, max flowrate: 24.9 mm³/s, max espeed: 10.4 mm/s, steps/s: 1459, steprate: 685 us, timervalue: */ 1370,
    /* Temp: 233.000000, max flowrate: 25.3 mm³/s, max espeed: 10.5 mm/s, steps/s: 1483, steprate: 674 us, timervalue: */ 1348,
    /* Temp: 234.000000, max flowrate: 25.7 mm³/s, max espeed: 10.7 mm/s, steps/s: 1506, steprate: 663 us, timervalue: */ 1327,
    /* Temp: 235.000000, max flowrate: 26.1 mm³/s, max espeed: 10.9 mm/s, steps/s: 1530, steprate: 653 us, timervalue: */ 1307,
    /* Temp: 236.000000, max flowrate: 26.5 mm³/s, max espeed: 11.0 mm/s, steps/s: 1553, steprate: 643 us, timervalue: */ 1287,
    /* Temp: 237.000000, max flowrate: 26.9 mm³/s, max espeed: 11.2 mm/s, steps/s: 1576, steprate: 634 us, timervalue: */ 1268,
    /* Temp: 238.000000, max flowrate: 27.3 mm³/s, max espeed: 11.4 mm/s, steps/s: 1600, steprate: 624 us, timervalue: */ 1249,
    /* Temp: 239.000000, max flowrate: 27.7 mm³/s, max espeed: 11.5 mm/s, steps/s: 1623, steprate: 615 us, timervalue: */ 1231,
    /* Temp: 240.000000, max flowrate: 28.1 mm³/s, max espeed: 11.7 mm/s, steps/s: 1647, steprate: 607 us, timervalue: */ 1214,
    /* Temp: 241.000000, max flowrate: 28.5 mm³/s, max espeed: 11.8 mm/s, steps/s: 1670, steprate: 598 us, timervalue: */ 1197,
    /* Temp: 242.000000, max flowrate: 28.9 mm³/s, max espeed: 12.0 mm/s, steps/s: 1694, steprate: 590 us, timervalue: */ 1180,
    /* Temp: 243.000000, max flowrate: 29.3 mm³/s, max espeed: 12.2 mm/s, steps/s: 1717, steprate: 582 us, timervalue: */ 1164,
    /* Temp: 244.000000, max flowrate: 29.7 mm³/s, max espeed: 12.3 mm/s, steps/s: 1741, steprate: 574 us, timervalue: */ 1148,
    /* Temp: 245.000000, max flowrate: 30.1 mm³/s, max espeed: 12.5 mm/s, steps/s: 1764, steprate: 566 us, timervalue: */ 1133,
    /* Temp: 246.000000, max flowrate: 30.5 mm³/s, max espeed: 12.7 mm/s, steps/s: 1787, steprate: 559 us, timervalue: */ 1118,
    /* Temp: 247.000000, max flowrate: 30.9 mm³/s, max espeed: 12.8 mm/s, steps/s: 1811, steprate: 552 us, timervalue: */ 1104,
    /* Temp: 248.000000, max flowrate: 31.3 mm³/s, max espeed: 13.0 mm/s, steps/s: 1834, steprate: 545 us, timervalue: */ 1090,
    /* Temp: 249.000000, max flowrate: 31.7 mm³/s, max espeed: 13.2 mm/s, steps/s: 1858, steprate: 538 us, timervalue: */ 1076,
    /* Temp: 250.000000, max flowrate: 32.1 mm³/s, max espeed: 13.3 mm/s, steps/s: 1881, steprate: 531 us, timervalue: */ 1062,
    /* Temp: 251.000000, max flowrate: 32.5 mm³/s, max espeed: 13.5 mm/s, steps/s: 1905, steprate: 524 us, timervalue: */ 1049,
    /* Temp: 252.000000, max flowrate: 32.9 mm³/s, max espeed: 13.7 mm/s, steps/s: 1928, steprate: 518 us, timervalue: */ 1037,
    /* Temp: 253.000000, max flowrate: 33.3 mm³/s, max espeed: 13.8 mm/s, steps/s: 1952, steprate: 512 us, timervalue: */ 1024,
    /* Temp: 254.000000, max flowrate: 33.7 mm³/s, max espeed: 14.0 mm/s, steps/s: 1975, steprate: 506 us, timervalue: */ 1012,
    /* Temp: 255.000000, max flowrate: 34.1 mm³/s, max espeed: 14.2 mm/s, steps/s: 1998, steprate: 500 us, timervalue: */ 1000,
    /* Temp: 256.000000, max flowrate: 34.5 mm³/s, max espeed: 14.3 mm/s, steps/s: 2022, steprate: 494 us, timervalue: */ 988,
    /* Temp: 257.000000, max flowrate: 34.9 mm³/s, max espeed: 14.5 mm/s, steps/s: 2045, steprate: 488 us, timervalue: */ 977,
    /* Temp: 258.000000, max flowrate: 35.3 mm³/s, max espeed: 14.7 mm/s, steps/s: 2069, steprate: 483 us, timervalue: */ 966,
    /* Temp: 259.000000, max flowrate: 35.7 mm³/s, max espeed: 14.8 mm/s, steps/s: 2092, steprate: 477 us, timervalue: */ 955,
    /* Temp: 260.000000, max flowrate: 36.1 mm³/s, max espeed: 15.0 mm/s, steps/s: 2116, steprate: 472 us, timervalue: */ 945,
    /* Temp: 261.000000, max flowrate: 36.5 mm³/s, max espeed: 15.2 mm/s, steps/s: 2139, steprate: 467 us, timervalue: */ 934,
    /* Temp: 262.000000, max flowrate: 36.9 mm³/s, max espeed: 15.3 mm/s, steps/s: 2163, steprate: 462 us, timervalue: */ 924,
    /* Temp: 263.000000, max flowrate: 37.3 mm³/s, max espeed: 15.5 mm/s, steps/s: 2186, steprate: 457 us, timervalue: */ 914,
    /* Temp: 264.000000, max flowrate: 37.7 mm³/s, max espeed: 15.7 mm/s, steps/s: 2210, steprate: 452 us, timervalue: */ 904,
    /* Temp: 265.000000, max flowrate: 38.1 mm³/s, max espeed: 15.8 mm/s, steps/s: 2233, steprate: 447 us, timervalue: */ 895,
    /* Temp: 266.000000, max flowrate: 38.5 mm³/s, max espeed: 16.0 mm/s, steps/s: 2256, steprate: 443 us, timervalue: */ 886,
    /* Temp: 267.000000, max flowrate: 38.9 mm³/s, max espeed: 16.2 mm/s, steps/s: 2280, steprate: 438 us, timervalue: */ 877,
    /* Temp: 268.000000, max flowrate: 39.3 mm³/s, max espeed: 16.3 mm/s, steps/s: 2303, steprate: 434 us, timervalue: */ 868,
    /* Temp: 269.000000, max flowrate: 39.7 mm³/s, max espeed: 16.5 mm/s, steps/s: 2327, steprate: 429 us, timervalue: */ 859,
};
#endif

/////////////////////////////////////////////////////////////////////////////////////


void printDebugInfo();

// xxx move to printer class?
void kill() {

    CLI(); // Stop interrupts
    disable_heater();

    printer.disableSteppers();

    // printDebugInfo();

    for (int i=0; i<1000; i++) {
        txBuffer.Run();
        delay(1);
        WDT_RESET();
    }

#if defined(POWER_SUPPLY_RELAY)
    POWER_SUPPLY_RELAY :: saveState();
#endif

}

void mAssert(uint16_t line, const char* file) {

    LCDMSGKILL(RespAssertion, line, file);

    txBuffer.flush();
    txBuffer.sendResponseStart(RespKilled);
    txBuffer.sendResponseUint8(RespAssertion);
    txBuffer.sendResponseUInt16(line);
    txBuffer.sendResponseString(file, strlen(file));
    txBuffer.sendResponseEnd();
    kill();
}

void killMessage(uint8_t errorCode, uint8_t errorParam, const char *msg) {

    LCDMSGKILL(errorCode, errorParam, msg);
    txBuffer.sendSimpleResponse(RespKilled, errorCode, errorParam);
    kill();
}

void killMessage(uint8_t errorCode, uint8_t errorParam1, uint8_t errorParam2, const char *msg) {

    LCDMSGKILL(errorCode, errorParam1, msg);
    txBuffer.sendSimpleResponse(RespKilled, errorCode, errorParam1, errorParam2);
    kill();
}

void setup() {

    // WDT_ENABLE();

    TIMER_INIT();

#if defined(POWER_SUPPLY_RELAY)
    // Switch on power relais to keep power
    // SET_OUTPUT(POWER_SUPPLY_RELAY);
    // WRITE(POWER_SUPPLY_RELAY, HIGH);
    POWER_SUPPLY_RELAY :: initActive();
#endif

#if defined(HOTEND_FAN_PIN)
    // SET_OUTPUT(HOTEND_FAN_PIN);
    // WRITE(HOTEND_FAN_PIN, ~ HOTEND_FAN_ACTIVE);
    HOTEND_FAN_PIN :: initDeActive();
#endif

#if defined(POWER_BUTTON)
    POWER_BUTTON :: init();
#endif

    LED_PIN :: init();

    FAN_PIN :: init();

    HAL_SPI_INIT();

    serialPort.begin(BAUDRATE);

    tp_init();    // Initialize temperature loop

    st_init();    // Initialize stepper, this enables interrupts!

    LED_PIN :: write(255 * 0.5);

    #if defined(REPRAP_DISCOUNT_SMART_CONTROLLER)
    lcd.begin(20, 4);
    lcd.print("OK");
    #endif
    
    if (! swapDev.swapInit()) {
        LCDMSGKILL(RespSDInit, "swapInit()", "");
        txBuffer.sendSimpleResponse(RespKilled, RespSDInit);
        kill();
    }

#if defined(PMWFS)
    filamentSensor.reset();
#endif

// #if defined(HASFILAMENTSENSOR)
    // filamentSensor.init();
// #endif

    HAL_IRQ_INIT();

    SEI();

    // tinf_init();
    TaskStart(taskTiming, TaskIdle);
}

//
// SDReader, read buffered stepdata from swapdevice
//

// Block-buffered sd read
class SDReader: public Protothread {

        // Buffer for block-wise reading of swap memory
        uint8_t buffer[SD_BUFFER_SIZE];

        // Number of characters in buffer
        int16_t bufferLength;

        // Readpointer into buffer
        uint16_t bufferPtr;

        // Number of bytes to read on current thread run
        uint16_t bytesToRead;

        // Temporary buffer if we cross a block boundary,
        // the size is 4 bytes - the length of the longest
        // datablock to read (see setBytesToReadX())
        uint8_t tempBuffer[4]; 

        uint16_t haveBytes;

    public:

        // Pointer to the result data, points into buffer directly or
        // to tempBuffer.
        uint8_t *readData;

        SDReader() {
            bufferLength = 0;
            bufferPtr = 0;
        }

        FWINLINE void setBytesToRead1() {
            Restart();
            bytesToRead = 1; } // Note: tempBuffer must be big enought to hold this number of bytes.
        FWINLINE void setBytesToRead2() {
            Restart();
            bytesToRead = 2; } // Note: tempBuffer must be big enought to hold this number of bytes.
        FWINLINE void setBytesToRead3() {
            Restart();
            bytesToRead = 3; } // Note: tempBuffer must be big enought to hold this number of bytes.
        FWINLINE void setBytesToRead4() {
            Restart();
            bytesToRead = 4; } // Note: tempBuffer must be big enought to hold this number of bytes.

        bool Run() {
// static bool readRequest=false;
            uint8_t i;

            PT_BEGIN();

            simassert((bytesToRead > 0) && (bytesToRead<5));
            simassert(bufferPtr <= bufferLength);

            haveBytes = bufferLength - bufferPtr;

            if (haveBytes < bytesToRead) {

                //
                // Read data from swap memory if not enough data in buffer 
                //
                if (haveBytes) {
                    //
                    // Copy the last bytes to temp buffer
                    //
                    for (i=0; i<haveBytes; i++) {
                        tempBuffer[i] = buffer[bufferPtr+i]; 
                        bytesToRead--;
                    }

                    //
                    // Get new block from swapmem
                    //
#if 0
if ((printerState == StateStart) && swapDev.isBusyWriting()) {
    assert(!readRequest);
    readRequest = true;
}
#endif
                    PT_WAIT_UNTIL(swapDev.available());
                    // PT_WAIT_WHILE(swapDev.isBusyWritingForRead());
                    // PT_WAIT_UNTIL((bufferLength = swapDev.readBlock(buffer)) > 0);
                    PT_WAIT_UNTIL(!swapDev.isBusyWritingForRead() && (bufferLength = swapDev.readBlock(buffer)) > 0);

                    for (i=0; i<bytesToRead; i++) {
                        tempBuffer[haveBytes+i] = buffer[i]; 
                    }

                    readData = tempBuffer;
                    bufferPtr = bytesToRead;
                }
                else {

                    //
                    // Buffer empty, get new block from swapmem
                    //
#if 0
if ((printerState == StateStart) && swapDev.isBusyWriting()) {
    assert(!readRequest);
    readRequest = true;
}
#endif
                    PT_WAIT_UNTIL(swapDev.available());
                    // PT_WAIT_WHILE(swapDev.isBusyWritingForRead());
                    // PT_WAIT_UNTIL((bufferLength = swapDev.readBlock(buffer)) > 0);
                    PT_WAIT_UNTIL(!swapDev.isBusyWritingForRead() && (bufferLength = swapDev.readBlock(buffer)) > 0);

                    readData = buffer;
                    bufferPtr = bytesToRead;
                }

                // massert(bufferLength > 0);
            }
            else {

                // Enough data in buffer to satisfy request
                readData = buffer + bufferPtr;
                bufferPtr += bytesToRead;
            }

            PT_END();
        }

        FWINLINE uint16_t available() {

            simassert(bufferLength >= bufferPtr);
            return bufferLength - bufferPtr;
        }

        uint16_t getBufferPtr() { return bufferPtr; }

        void flush() {

            bufferLength = bufferPtr = 0;

            //
            // Restart is done in setBytesToReadX().
            //
            swapDev.reset();
        }
};

static SDReader sDReader;

class FillBufferTask : public Protothread {

        uint16_t flags;
        uint8_t timerLoop;
        uint16_t lastTimer;

        uint16_t nAccel;
        uint8_t leadAxis;
        uint16_t tLin;
        uint16_t nDecel;
        int32_t absSteps[5];

        // Bresenham factors
        int32_t d_axis[5];
        int32_t d1_axis[5];
        int32_t d2_axis[5];

        int32_t deltaLead, step;

        // Hotend target temp for CmdSyncTargetTemp
        // uint8_t targetHeater;
        // uint16_t targetTemp;

        // Hotend target pwm for CmdSyncHotendPWM
        // uint8_t heaterPWM;
        // unsigned long pulseEnd;

        // Number of 25 mS nop segments for G4/dwell
        uint16_t nDwell;

        bool cmdSync;
        bool stopRequested;

#if defined(USEExtrusionRateTable)
        // Scaling factor for timerValues to implement temperature speed limit 
        float timerScale;
#endif

        stepData sd;

    public:
        FillBufferTask() {
            sd.dirBits = 0;
            cmdSync = false;
            stopRequested = false;
            pulseEnd = 0;
        }

        // xxxx getter/setter
        uint8_t targetHeater;
        uint32_t pulsePause;
        unsigned long pulseEnd;
        uint16_t targetTemp;

        bool Run() {

            uint8_t i, cmd;

            int32_t d;
            int32_t d1;
            int32_t d2;

#if defined(USEExtrusionRateTable)
            // Timervalue of max e-speed of our basemove
            uint16_t    eSpeedTimer;
            float maxTempSpeed;
#endif

            PT_BEGIN();

            #if 0
            # Move segment data, new with bresenham in firmware:
            #   * Header data:
            #       + 8 flag bits
            #       + index lead axis, 8 bits
            #       + array of absolute steps, 5 * 16 bits
            #       + number of accel steps, naccel, 16 bits
            #       + constant linear timer value, 16 bits
            #       + number of decel steps, ndccel, 16 bits
            #
            #   * accel steps: naccel*(timer value(16bits)) or 16bits + (naccel-1)*8bits
            #
            #   * decel steps: ndecel*(timer value(16bits)) or 16bits + (naccel-1)*8bits
            #endif

            sDReader.setBytesToRead1();
            PT_WAIT_THREAD(sDReader);
            cmd = *sDReader.readData;

            switch (cmd) {

                case CmdG1:
                case CmdG1Packed:
                    goto HandleCmdG1;

                case CmdG1Raw:
                case CmdG1RawPacked:
                    goto HandleCmdG1Raw;

                case CmdSyncFanSpeed:
                    goto HandleCmdSyncFanSpeed;

                case CmdSyncTargetTemp:
                    goto HandleCmdSyncTargetTemp;

                case CmdDwellMS:
                    goto HandleCmdDwellMS;

                case CmdSuggestPwm:
                    goto HandleCmdSuggestPwm;

                default:
                    killMessage(RespUnknownBCommand, cmd);
            }

            HandleCmdG1:

                // Read flag word and stepper direction bits
                sDReader.setBytesToRead2();
                PT_WAIT_THREAD(sDReader);

                flags = FromBuf(uint16_t, sDReader.readData);

                if (flags & 0x80)
                    // Change stepper direction(s)
                    sd.dirBits = flags & 0x9F;

                cmdSync = true;

                //
                // Read index of lead axis
                //
                sDReader.setBytesToRead1();
                PT_WAIT_THREAD(sDReader);
                leadAxis = *sDReader.readData;

                //
                // Read array of absolute step distances of the 5 axes
                //
                sDReader.setBytesToRead4();
                PT_WAIT_THREAD(sDReader);
                absSteps[0] = FromBuf(int32_t, sDReader.readData);

                sDReader.setBytesToRead4();
                PT_WAIT_THREAD(sDReader);
                absSteps[1] = FromBuf(int32_t, sDReader.readData);

                sDReader.setBytesToRead4();
                PT_WAIT_THREAD(sDReader);
                absSteps[2] = FromBuf(int32_t, sDReader.readData);

                sDReader.setBytesToRead4();
                PT_WAIT_THREAD(sDReader);
                absSteps[3] = FromBuf(int32_t, sDReader.readData);

                sDReader.setBytesToRead4();
                PT_WAIT_THREAD(sDReader);
                absSteps[4] = FromBuf(int32_t, sDReader.readData);

                sDReader.setBytesToRead2();
                PT_WAIT_THREAD(sDReader);
                nAccel = FromBuf(uint16_t, sDReader.readData);

#if defined(USEExtrusionRateTable)
                //////////////////////////////////////////////////////
                // Check beginning of new base move
                if (flags & 0x100) {

                    sDReader.setBytesToRead2();
                    PT_WAIT_THREAD(sDReader);

                    eSpeedTimer = FromBuf(uint16_t, sDReader.readData);
                    // setNAvg(FromBuf(uint8_t, sDReader.readData));

                    // printf("eSpeedTimer: %d\n", eSpeedTimer);

                    if (eSpeedTimer > 0) {

                        // Lookup this e-speed in the extrusion rate table
                        // int16_t curTempIndex = (current_temperature[0] - extrusionLimitBaseTemp) / 2;
                        int16_t curTempIndex = current_temperature[0] - extrusionLimitBaseTemp;

                        // printf("curTempIndex: %d\n", curTempIndex);

                        if (curTempIndex < 0) {

                            // printf("temp very low, use first entry\n");
                            maxTempSpeed = tempExtrusionRateTable[0];
                        }
                        else if (curTempIndex >= NExtrusionLimit) {

                            // printf("temp very high, use last entry\n");
                            maxTempSpeed = tempExtrusionRateTable[NExtrusionLimit-1];
                        }
                        else {

                            // printf("temp in range\n");
                            maxTempSpeed = tempExtrusionRateTable[curTempIndex];
                        }

                        if (eSpeedTimer < maxTempSpeed) {

                            // Speed is limited by temperature
                            // XXX cleanup temptable: store temptable as floats or use integer (*1000) numeric here...
                            timerScale = (maxTempSpeed / eSpeedTimer) * VAR_FILSENSOR_GRIP;
                            // printf("speed is limited by factor: %f\n", timerScale);
                        }
                        else {
                            // Speed is not limited by temperature
                            timerScale = VAR_FILSENSOR_GRIP;
                        }
                    }
                    else {
                        // Non-printmove
                        timerScale = 1.0;
                    }
                }

                if (flags & 0x200) {
                    // Start filament sensor measurement
                    sDReader.setBytesToRead1();
                    PT_WAIT_THREAD(sDReader);
                    setNAvg(FromBuf(uint8_t, sDReader.readData));
                }


// xxx cleanup temptable
// #if defined(HEAVYDEBUG)
                massert(timerScale >= 1.0);
// #endif
                //////////////////////////////////////////////////////
#endif

                sDReader.setBytesToRead2();
                PT_WAIT_THREAD(sDReader);

                tLin = STD min ( (uint16_t)(FromBuf(uint16_t, sDReader.readData) * timerScale), (uint16_t)0xffff);

                // nDecel = sDReader.readPayloadUInt16();
                sDReader.setBytesToRead2();
                PT_WAIT_THREAD(sDReader);
                nDecel = FromBuf(uint16_t, sDReader.readData);

                //
                // Compute bresenham factors
                //

                deltaLead = absSteps[leadAxis];

                //  d = (2 * deltay) - deltax 
                //    = d1 - deltax
                // d1 = (2 * deltay)
                // d2 = 2 * (deltay - deltax)
                //    = 2 * deltay - 2 * deltax
                //    = d - deltax
                for (i=0; i<5; i++) {

                    if (i == leadAxis)
                        continue;

                    d1 = 2 * absSteps[i];
                    d = d1 - deltaLead;
                    d2 = d - deltaLead;

                    d_axis[i] = d;
                    d1_axis[i] = d1;
                    d2_axis[i] = d2;
                }

                if (nAccel) {

                    //
                    // Acceleration, get first timer value
                    //
                    sDReader.setBytesToRead2();
                    PT_WAIT_THREAD(sDReader);
                    lastTimer = FromBuf(uint16_t, sDReader.readData);

                    sd.timer = STD min ( (uint16_t)(lastTimer * timerScale), (uint16_t)0xffff );
                    computeStepBits();
                    PT_WAIT_WHILE(stepBuffer.full2());
                    stepBuffer.push(sd);
                    sd.dirBits &= ~0x80; // clear set-direction bit (after push)

                    if (flags & AccelByteFlag) {

                        // Timer value as 8bit difference
                        for (step = 1; step < nAccel; step++) {

                            sDReader.setBytesToRead1();
                            PT_WAIT_THREAD(sDReader);
                            lastTimer -= FromBuf(uint8_t, sDReader.readData);

                            sd.timer = STD min ( (uint16_t)(lastTimer * timerScale),  (uint16_t)0xffff );
                            computeStepBits();
                            PT_WAIT_WHILE(stepBuffer.full2());
                            stepBuffer.push(sd);
                        }
                    }
                    else {

                        // Timer value as 16bit absolute value
                        for (step = 1; step < nAccel; step++) {

                            sDReader.setBytesToRead2();
                            PT_WAIT_THREAD(sDReader);
                            sd.timer = STD min ( (uint16_t)(FromBuf(uint16_t, sDReader.readData) * timerScale), (uint16_t)0xffff );

                            computeStepBits();
                            PT_WAIT_WHILE(stepBuffer.full2());
                            stepBuffer.push(sd);
                        }
                    }
                }

                //
                // Constant phase
                //
                step = deltaLead - (nAccel+nDecel);
                if (step) {

                    sd.timer = tLin;

                    computeStepBits();
                    PT_WAIT_WHILE(stepBuffer.full2());
                    stepBuffer.push(sd);

                    sd.dirBits &= ~0x80; // clear set-direction bit (after push)

                    for (; step > 1; step--) {

                        computeStepBits();
                        PT_WAIT_WHILE(stepBuffer.full2());
                        stepBuffer.push(sd);
                    }
                }

                if (nDecel) {

                    //
                    // Deceleration, get first timer value
                    //
                    sDReader.setBytesToRead2();
                    PT_WAIT_THREAD(sDReader);
                    lastTimer = FromBuf(uint16_t, sDReader.readData);

                    sd.timer = STD min ( (uint16_t)(lastTimer * timerScale), (uint16_t)0xffff );

                    computeStepBits();
                    PT_WAIT_WHILE(stepBuffer.full2());
                    stepBuffer.push(sd);

                    sd.dirBits &= ~0x80; // clear set-direction bit (after push)

                    if (flags & DecelByteFlag) {

                        // Timer value as 8bit difference
                        for (step = 1; step < nDecel; step++) {

                            sDReader.setBytesToRead1();
                            PT_WAIT_THREAD(sDReader);
                            lastTimer += FromBuf(uint8_t, sDReader.readData);

                            sd.timer = STD min ( (uint16_t)(lastTimer * timerScale),  (uint16_t)0xffff );

                            computeStepBits();
                            PT_WAIT_WHILE(stepBuffer.full2());
                            stepBuffer.push(sd);
                        }
                    }
                    else {

                        // Timer value as 16bit absolute value
                        for (step = 1; step < nDecel; step++) {

                            sDReader.setBytesToRead2();
                            PT_WAIT_THREAD(sDReader);
                            sd.timer = STD min ( (uint16_t)(FromBuf(uint16_t, sDReader.readData) * timerScale), (uint16_t)0xffff );

                            computeStepBits();
                            PT_WAIT_WHILE(stepBuffer.full2());
                            stepBuffer.push(sd);
                        }
                    }
                }

                if (flags & 0x0400) {
                    // Endmove, speed is lower or equal jerk speed, so this is a good
                    // candidate for a printer stop...
                    if (stopRequested) {

                        // printf("softstopopping... %d bytes\n", stepBuffer.byteSize());
                        // Empty sdreader but let stepbuffer drain normally: 
                        sDReader.flush(); // resets swapdev also
                    }
                }

                PT_RESTART();

            HandleCmdG1Raw:

                // Read flag word and stepper direction bits
                sDReader.setBytesToRead2();
                PT_WAIT_THREAD(sDReader);

                flags = FromBuf(uint16_t, sDReader.readData);

                if (flags & 0x80)
                    // Change stepper direction(s)
                    sd.dirBits = flags & 0x9F;

                // ???
                // cmdSync = true;

                //
                // Read len of pulses array, 2 bytes short uint
                //
                sDReader.setBytesToRead2();
                PT_WAIT_THREAD(sDReader);
                nAccel = FromBuf(uint16_t, sDReader.readData);

#if defined(USEExtrusionRateTable)
                //////////////////////////////////////////////////////
                // Check beginning of new base move
                if (flags & 0x20) {

                    sDReader.setBytesToRead2();
                    PT_WAIT_THREAD(sDReader);

                    eSpeedTimer = FromBuf(uint16_t, sDReader.readData);
                    // setNAvg(FromBuf(uint8_t, sDReader.readData));

                    // printf("eSpeedTimer: %d\n", eSpeedTimer);

                    // Lookup this e-speed in the extrusion rate table
                    // int16_t curTempIndex = (current_temperature[0] - extrusionLimitBaseTemp) / 2;
                    int16_t curTempIndex = current_temperature[0] - extrusionLimitBaseTemp;

                    // printf("curTempIndex: %d\n", curTempIndex);

                    if (curTempIndex < 0) {

                        // printf("temp very low, use first entry\n");
                        maxTempSpeed = tempExtrusionRateTable[0];
                    }
                    else if (curTempIndex >= NExtrusionLimit) {

                        // printf("temp very high, use last entry\n");
                        maxTempSpeed = tempExtrusionRateTable[NExtrusionLimit-1];
                    }
                    else {

                        // printf("temp in range\n");
                        maxTempSpeed = tempExtrusionRateTable[curTempIndex];
                    }

                    if (eSpeedTimer < maxTempSpeed) {
                        // Speed is limited by temperature
                        // XXX cleanup temptable store temptable as floats or use integer (*1000) numeric here...
                        timerScale = (maxTempSpeed / eSpeedTimer) * VAR_FILSENSOR_GRIP;
                        // printf("speed is limited by factor: %f\n", timerScale);
                    }
                    else {
                        // Speed is not limited by temperature
                        timerScale = VAR_FILSENSOR_GRIP;
                    }
                }
    
                if (flags & 0x100) {
                    // Start filament sensor measurement
                    sDReader.setBytesToRead1();
                    PT_WAIT_THREAD(sDReader);
                    setNAvg(FromBuf(uint8_t, sDReader.readData));
                }

// xxx cleanup temptable
// #if defined(HEAVYDEBUG)
                massert(timerScale >= 1.0);
// #endif
                //////////////////////////////////////////////////////
#endif

                sDReader.setBytesToRead2();
                PT_WAIT_THREAD(sDReader);
                lastTimer = FromBuf(uint16_t, sDReader.readData);
                sd.timer = STD min ( (uint16_t)(lastTimer * timerScale), (uint16_t)0xffff );

                sDReader.setBytesToRead1();
                PT_WAIT_THREAD(sDReader);
                sd.stepBits = *sDReader.readData;

                PT_WAIT_WHILE(stepBuffer.full2());
                stepBuffer.push(sd);

                sd.dirBits &= ~0x80; // clear set-direction bit (after push)

                if (flags & RawByteFlag) {
                    //
                    // Read pulse array, first element is a 16bit timer value and 8bit stepper mask,
                    // then elements of 8bit timer delta and 8bit stepper mask
                    //
                    for (step=1; step < nAccel; step++) {

                        sDReader.setBytesToRead1();
                        PT_WAIT_THREAD(sDReader);
                        lastTimer += FromBuf(int8_t, sDReader.readData);
                        sd.timer = STD min ( (uint16_t)(lastTimer * timerScale), (uint16_t)0xffff );

                        sDReader.setBytesToRead1();
                        PT_WAIT_THREAD(sDReader);
                        sd.stepBits = *sDReader.readData;

                        PT_WAIT_WHILE(stepBuffer.full2());
                        stepBuffer.push(sd);
                    }
                }
                else {
                    //
                    // Read pulse array, elements of 16bit timer and 8bit stepper mask
                    //
                    for (step=1; step < nAccel; step++) {

                        sDReader.setBytesToRead2();
                        PT_WAIT_THREAD(sDReader);
                        sd.timer = STD min ( (uint16_t)(FromBuf(uint16_t, sDReader.readData) * timerScale), (uint16_t)0xffff );

                        massert(sd.timer >= 25); // xxxx  hardcoded...

                        sDReader.setBytesToRead1();
                        PT_WAIT_THREAD(sDReader);
                        sd.stepBits = *sDReader.readData;

                        PT_WAIT_WHILE(stepBuffer.full2());
                        stepBuffer.push(sd);
                    }
                }

                if (flags & 0x0200) {
                    // Endmove, speed is lower or equal jerk speed, so this is a good
                    // candidate for a printer stop...
                    if (stopRequested) {

                        // printf("softstopopping... %d bytes\n", stepBuffer.byteSize());
                        // Empty sdreader but let stepbuffer drain normally: 
                        sDReader.flush(); // resets swapdev also
                    }
                }

                PT_RESTART();

            HandleCmdSyncFanSpeed:

                // Read fanspeed, bliptime
                sDReader.setBytesToRead2();
                PT_WAIT_THREAD(sDReader);

                printer.cmdFanSpeed(*sDReader.readData, *(sDReader.readData+1));

                PT_RESTART();

            HandleCmdSyncTargetTemp:

                sDReader.setBytesToRead3();
                PT_WAIT_THREAD(sDReader);

                printer.cmdSetTargetTemp(*sDReader.readData, FromBuf(uint16_t, sDReader.readData+1));

                PT_RESTART();

            HandleCmdDwellMS:

                //
                // Dwell is is done by executing a number of *NOP* moves that don't step any stepper
                // but are waiting for 25 mS.
                //
                // Read number of 25 mS nop segemnts as 16 bit unsigned int
                sDReader.setBytesToRead2();
                PT_WAIT_THREAD(sDReader);

                nDwell = FromBuf(uint16_t, sDReader.readData);

                sd.stepBits = 0;     // We don't step
                sd.timer    = 50000; // 25 mS for 2 mhz clock

                while (nDwell-- > 0) {

                    PT_WAIT_WHILE(stepBuffer.full2());
                    stepBuffer.push(sd);
                }

                PT_RESTART();

            HandleCmdSuggestPwm:

                sDReader.setBytesToRead4();
                PT_WAIT_THREAD(sDReader);

                targetHeater = *sDReader.readData;
                targetTemp = FromBuf(uint16_t, sDReader.readData+1);

                tempControl.suggestPwm = *(sDReader.readData+3);

                printer.cmdSetTargetTemp(*sDReader.readData, FromBuf(uint16_t, sDReader.readData+1));

                PT_RESTART();

            PT_END(); // Not reached
        }


        void sync() {
            cmdSync = false;
        }

        bool synced() {
            return cmdSync;
        }

        // Flush/init swap, swapreader, fillbuffer task and stepbuffer
        void flush() {

            step = deltaLead;
            cmdSync = false;
            stopRequested = false;
            Restart();

            sDReader.flush(); // resets swapdev also
            stepBuffer.flush();
        }


        // Request a printer soft stop
        void requestSoftStop() { stopRequested = true; }

        //
        // Compute stepper bits, bresenham
        //
        FWINLINE void computeStepBits() {

            sd.stepBits = 1 << leadAxis;

            for (uint8_t i=0; i<5; i++) {

                if (i == leadAxis)
                    continue;

                if (d_axis[i] < 0) {
                    //  d_axis[a] = d + 2 * abs_displacement_vector_steps[a]
                    d_axis[i] += d1_axis[i];
                }
                else {
                    //  d_axis[a] = d + 2 * (abs_displacement_vector_steps[a] - deltaLead)
                    d_axis[i] += d2_axis[i];
                    sd.stepBits |= 1 << i;
                }
            }
        }

};

FillBufferTask fillBufferTask;

void Timer::run(unsigned long m) {

    if (fanEndTime && (m >= fanEndTime)) {

        FAN_PIN :: write(fanSpeed);
        fanEndTime = 0;
    }

#if defined(__arm__)
    if (bootBootloaderRequest) {

        // Wait until we sent our acknowledge to keep
        // usb-serial communication clean.
        if (txBuffer.empty()) {
            JumpToBootloader();
            // notreached
        }
    }
#endif

    if (resetRequest) {

        // Wait until we sent our acknowledge to keep
        // usb-serial communication clean.
        if (txBuffer.empty()) {
            HAL_SYSTEM_RESET();
            // notreached
        }
    }
}

Timer timer;


Printer::Printer() {

    printerState = StateIdle;
    moveType = MoveTypeNone;
    homed = false;
    swapErased = false;

    for (int heater=0; heater<N_HEATERS; heater++)
        increaseTemp[heater] = 0;

    powerOffTime = 0;

    bufferLow = 0;
};

void Printer::printerInit() {

    // XXX handle already running state
    massert(printerState <= StateInit);

    nGenericMessage = 0;

    //
    // Erase sd-swap to speed up block writes.
    //
    if (! swapErased) {

        uint32_t msSizeInBlocks = swapDev.cardSize();

        massert(msSizeInBlocks > 0);
        massert(swapDev.erase(1, msSizeInBlocks - 1));

        swapErased = true;
    }

    // Init buffers
    fillBufferTask.flush();

    printerState = StateInit;
    eotReceived = false;

    LED_PIN :: write(255);
}


void Printer::sendGenericMessage(const char *s, uint8_t l) {

    if (nGenericMessage++ > 50)
        return;

    txBuffer.sendResponseStart(RespUnsolicitedMsg);
    txBuffer.sendResponseUint8(GenericMessage);
    txBuffer.sendResponseString(s, l);
    txBuffer.sendResponseEnd();
}

void Printer::runHotEndFan() {

#if defined(HOTEND_FAN_PIN)
    if ((hotEndFanOn == false) && (current_temperature[0] >= 40.0)) {

        // Hotend fan on
        HOTEND_FAN_PIN :: activate();
        hotEndFanOn = true;
    }
    else if ((hotEndFanOn == true) && (current_temperature[0] <= 35.0)) {

        // Hotend fan off
        HOTEND_FAN_PIN :: deActivate();
        hotEndFanOn = false;
    }
#endif

}

void Printer::cmdEot() {

    massert(printerState >= StateInit);

    eotReceived = true;

    if (swapDev.getWritePos()) {
        // Save last partial block
        // xxx check busy here
        swapDev.startWriteBlock();
    }
}

void Printer::runFillBuffer() {
    fillBufferTask.Run();
}

void Printer::underrunError() {

    printer.bufferLow = min((uint32_t)printer.bufferLow+1, (uint32_t)0xffff);

    txBuffer.sendResponseStart(RespUnsolicitedMsg);
    txBuffer.sendResponseUint8(BufDebug);
    txBuffer.sendResponseUInt32(swapDev.available());
    txBuffer.sendResponseUInt32((uint32_t)sDReader.available());
    txBuffer.sendResponseEnd();
}

#if 0
void Printer::underrunError(uint32_t lastSize, uint32_t lastSize2, uint32_t minTimer) {

    txBuffer.flush();
    txBuffer.sendResponseStart(RespUnderrun);
    txBuffer.sendResponseUInt32(lastSize);
    txBuffer.sendResponseUInt32(lastSize2);
    txBuffer.sendResponseUInt32(minTimer);
    txBuffer.sendResponseUInt32(swapDev.available());
    txBuffer.sendResponseUInt32((uint32_t)sDReader.available());
    txBuffer.sendResponseEnd();
    kill();
}
#endif

void Printer::cmdMove(MoveType mt) {

    massert(mt != MoveTypeNone);
    massert(printerState == StateInit);

    printerState = StateStart;
    moveType = mt;

    minBufferMax = 0;
    minBuffer = 0;

    // if (mt == MoveTypeNormal) {
        // armrun massert(homed);
    // }

    if (mt == MoveTypeHoming) {
        // ENABLE_STEPPER1_DRIVER_INTERRUPT();
        stepBuffer.homingMode();
    }
    else {
        ENABLE_STEPPER_DRIVER_INTERRUPT();
        // minBuffer = stepBuffer.byteSize();
    }

    enable_x();
    enable_y();
    enable_z();

#if ! defined(COLDEXTRUSION)
    enable_e0();
#endif

    bufferLow = 0;

#if defined(HASFILAMENTSENSOR)
    filamentSensor.init();
#endif
}

void Printer::setHomePos(int32_t x, int32_t y, int32_t z) {
         
    homed = true;

    current_pos_steps[X_AXIS] = x;
    current_pos_steps[Y_AXIS] = y;
    current_pos_steps[Z_AXIS] = z;
}

void Printer::cmdSetTargetTemp(uint8_t heater, uint16_t temp) {

    if (temp > 50)
        tempControl.setTemp(heater, temp + increaseTemp[heater]);
    else
        tempControl.setTemp(heater, temp);
}

void Printer::cmdSetIncTemp(uint8_t heater, int16_t incTemp) {

    massert((heater >= 0) && (heater < N_HEATERS));
    massert(abs(incTemp) <= 15);

    increaseTemp[heater] = incTemp;
}

void Printer::cmdGetFreeMem() {

    txBuffer.sendResponseStart(CmdGetFreeMem);
    txBuffer.sendResponseUInt32((uint32_t)freeRam());
    txBuffer.sendResponseEnd();
}

void Printer::cmdGetFSReadings(uint8_t nReadings) {

    txBuffer.sendResponseStart(CmdGetFSReadings);

    uint8_t start = filsensorReadingIndex - (nReadings + 1);

    while (nReadings--) {

        txBuffer.sendResponseUInt32((uint32_t)filsensorReadings[start].timeStamp);
        txBuffer.sendResponseInt16(filsensorReadings[start].dy);
        start++;
    }

    txBuffer.sendResponseEnd();
}

void Printer::cmdSetPIDValues(float kp, float ki, float kd, uint16_t tu) {

    tempControl.setPIDValues(kp, ki, kd);
    Tu = tu;
}

void Printer::cmdSetStepsPerMM(uint16_t spmmX, uint16_t spmmY, uint16_t spmmZ) {
    stepsPerMMX = spmmX;
    stepsPerMMY = spmmY;
    stepsPerMMZ = spmmZ;
}

void Printer::cmdFanSpeed(uint8_t speed, uint8_t blipTime) {

    // If no blip is used, start fan directly, else
    // start fan at 100% and start a timer to lower
    // pwm value after the bliptime.
    if (blipTime) {

        FAN_PIN :: write(255);
        timer.startFanTimer(speed, blipTime);
        return;
    }

    timer.endFanTimer();
    FAN_PIN :: write(speed);
}

void Printer::cmdContinuousE(uint16_t timerValue) {

    // xxx add new printerstate for continuos mode here...
    stepBuffer.continuosMode(timerValue);
}

/*
 * Hard stop, without deceleration
 */
void Printer::cmdStopMove() {

    cmdSetTargetTemp(0, 0);
    cmdSetTargetTemp(1, 0);
#if EXTRUDERS > 1
    cmdSetTargetTemp(2, 0);
#endif

    DISABLE_STEPPER_DRIVER_INTERRUPT();
    DISABLE_STEPPER1_DRIVER_INTERRUPT();

    printerState = StateInit;
    moveType = MoveTypeNone;

    // Flush remaining steps
    fillBufferTask.flush();

    cmdFanSpeed(0, 0);
}

void Printer::cmdGetTargetTemps() {

    txBuffer.sendResponseStart(CmdGetTargetTemps);

    txBuffer.sendResponseUint8(target_temperature_bed);
    txBuffer.sendResponseUInt16(target_temperature[0]);
#if EXTRUDERS > 1
    txBuffer.sendResponseUInt16(target_temperature[1]);
#endif
    txBuffer.sendResponseEnd();
}

void Printer::cmdGetCurrentTemps() {

    txBuffer.sendResponseStart(CmdGetCurrentTemps);

    txBuffer.sendResponseFloat(current_temperature_bed);
    txBuffer.sendResponseFloat(current_temperature[0]);
#if EXTRUDERS > 1
    txBuffer.sendResponseFloat(current_temperature[1]);
#endif
    txBuffer.sendResponseEnd();
}

// Note: we don't check if mass-storage is busy.
// Note: we don't merge the config here, we just overwrite it.
// This is no problem as long the config is just the printer name. 
void Printer::cmdSetPrinterName(char *name, uint8_t len) {

    union MSConfigBlock configSector;

    memset(configSector.config.printerName, 0, sizeof(configSector.config.printerName));
    strncpy(configSector.config.printerName, name, STD min(len, (uint8_t)sizeof(configSector.config.printerName)));

    // No error checking
    swapDev.writeConfig(configSector);

    txBuffer.sendResponseStart(CmdSetPrinterName);
    txBuffer.sendResponseUint8(RespOK);
    txBuffer.sendResponseEnd();
}

// Note: we don't check if mass-storage is busy.
void Printer::cmdGetPrinterName() {

    union MSConfigBlock configSector;

    // No error checking
    swapDev.readConfig(configSector);

    txBuffer.sendResponseStart(CmdGetPrinterName);
    txBuffer.sendResponseUint8(RespOK);
    txBuffer.sendResponseString(
            configSector.config.printerName,
            strnlen(configSector.config.printerName, sizeof(configSector.config.printerName)-1));
    txBuffer.sendResponseEnd();
}

void Printer::checkMoveFinished() {

    //
    // Move is finished if:
    // * eot was received (sender has sent all data)
    // * read file pos is at the end of file
    // * buffers are empty
    //
    if (printerState == StateStart) {

        if ((moveType == MoveTypeHoming) && (! STEPPER1_DRIVER_INTERRUPT_ENABLED())) {

            // Flush remaining steps
            fillBufferTask.flush();
        }

        if ( eotReceived &&
             (! swapDev.isBusyWritingForWrite()) &&
             (! swapDev.available()) &&
             (! sDReader.available()) &&
             stepBuffer.empty() ) {

            // printf("finish ok...\n");

            DISABLE_STEPPER_DRIVER_INTERRUPT();
            DISABLE_STEPPER1_DRIVER_INTERRUPT();

            // hack, stepbuffer adds an invalid bufferunderrun at the end of the move...
            // if (moveType == MoveTypeNormal)
                // bufferLow -= 1;

            printerState = StateInit;
            moveType = MoveTypeNone;

            // Reset swap/buffers
            fillBufferTask.flush();

            eotReceived = false;
            // bufferLow = -1;
        }
    }
}

void Printer::disableSteppers() {

    st_disableSteppers();

    homed = false;
    LED_PIN :: write(255 * 0.5);
}

void Printer::cmdDisableSteppers() {

    disableSteppers();
}

#if 0
// Currently not used:
void Printer::cmdDisableStepperIsr() {

    DISABLE_STEPPER_DRIVER_INTERRUPT();
    DISABLE_STEPPER1_DRIVER_INTERRUPT();
}
#endif

void Printer::cmdGetHomed() {

    txBuffer.sendResponseStart(CmdGetHomed);
    txBuffer.sendResponseUint8((uint8_t)homed);
    txBuffer.sendResponseEnd();
}

void Printer::cmdGetEndstops() {

    txBuffer.sendResponseStart(CmdGetEndstops);

    txBuffer.sendResponseUint8(X_STOP_PIN :: active());
    txBuffer.sendResponseInt32(current_pos_steps[X_AXIS]);

    txBuffer.sendResponseUint8(Y_STOP_PIN :: active());
    txBuffer.sendResponseInt32(current_pos_steps[Y_AXIS]);

    txBuffer.sendResponseUint8(Z_STOP_PIN :: active());
    txBuffer.sendResponseInt32(current_pos_steps[Z_AXIS]);

    txBuffer.sendResponseEnd();
}

void Printer::cmdGetPos() {

    txBuffer.sendResponseStart(CmdGetPos);
    txBuffer.sendResponseBlob((uint8_t*)current_pos_steps, sizeof(current_pos_steps));
    txBuffer.sendResponseEnd();
}

#if 0
void Printer::cmdGetDirBits() {

    uint8_t dirbits =
        st_get_direction<XAxisSelector>() |
        st_get_direction<YAxisSelector>() |
        st_get_direction<ZAxisSelector>() |
        st_get_direction<EAxisSelector>();

    txBuffer.sendResponseStart(CmdGetDirBits);
    txBuffer.sendResponseUint8(dirbits);
    txBuffer.sendResponseEnd();
}
#endif

// debug



// log of stepbuffer fill state
typedef struct {
    uint32_t timestamp;
    uint16_t sdsize;
} filltrace;

typedef CircularBuffer<filltrace, uint16_t, 256> StepBufferLog;

StepBufferLog stepBufferLog;




void Printer::cmdGetTaskStatus() {
txBuffer.sendResponseStart(CmdGetTaskStatus);

    for (uint8_t i=0; i<(sizeof(taskTiming) / sizeof(taskTiming[0])); i++) {
#if defined(DEBUGPROCSTAT)
        txBuffer.sendResponseUInt32(taskTiming[i].ncalls);
        txBuffer.sendResponseUInt32(taskTiming[i].sumcall);
        txBuffer.sendResponseUInt32(taskTiming[i].longest);
#else
        txBuffer.sendResponseUInt32(0);
        txBuffer.sendResponseUInt32(0);
        txBuffer.sendResponseUInt32(0);
#endif
    }
    txBuffer.sendResponseEnd();
} 











void Printer::cmdGetIOStats() {

    txBuffer.sendResponseStart(CmdGetIOStats);

    // for (uint8_t i=0; i<(sizeof(ioStats) / sizeof(ioStats[0])); i++) {
    for (uint8_t i=0; i<4; i++) { // XXX
#if defined(DEBUGREADWRITE)
        txBuffer.sendResponseUInt32(swapDev.ioStats[i].ncalls);
        txBuffer.sendResponseUInt32(swapDev.ioStats[i].sumcall);
        txBuffer.sendResponseUInt32(swapDev.ioStats[i].longest);
#else
        txBuffer.sendResponseUInt32(0);
        txBuffer.sendResponseUInt32(0);
        txBuffer.sendResponseUInt32(0);
#endif
    }
    txBuffer.sendResponseEnd();
}

void Printer::cmdGetStatus() {
//0
    txBuffer.sendResponseStart(CmdGetStatus);

//1
    txBuffer.sendResponseUint8(printerState);
//2
    txBuffer.sendResponseFloat(current_temperature_bed);
//6
    txBuffer.sendResponseFloat(current_temperature[0]);
//10
    txBuffer.sendResponseUInt32(swapDev.available());
//14
    txBuffer.sendResponseUInt16(sDReader.available());
//12
    // xxx undo txBuffer.sendResponseUint8(stepBuffer.byteSize());
    txBuffer.sendResponseUInt32(stepBuffer.size());
    txBuffer.sendResponseInt16(bufferLow);
    txBuffer.sendResponseUInt16(target_temperature[0]);
    txBuffer.sendResponseUint8(tempControl.getPwmOutput());

    // Flowrate sensor
#if defined(HASFILAMENTSENSOR)
    // txBuffer.sendResponseInt16(filamentSensor.targetSpeed.value());
    // txBuffer.sendResponseInt16(filamentSensor.targetSpeed);
    // txBuffer.sendResponseInt16(filamentSensor.actualSpeed.value());
    // txBuffer.sendResponseValue(filamentSensor.slippage.value());
    // xxx move to filsensor class
    txBuffer.sendResponseFloat(filamentSensor.slippage());
    // txBuffer.sendResponseValue(filamentSensor.grip);
#else
    txBuffer.sendResponseFloat(0.0);
    // txBuffer.sendResponseInt16(0);
#endif

    txBuffer.sendResponseInt32(current_pos_steps[E_AXIS]);
    txBuffer.sendResponseUInt32(minBuffer);

    txBuffer.sendResponseEnd();
}

#if defined(HASFILAMENTSENSOR)
void Printer::cmdGetFilSensor() {

    txBuffer.sendResponseStart(CmdGetFilSensor);
    txBuffer.sendResponseInt32(filamentSensor.getSensorCount());
    txBuffer.sendResponseEnd();
}
#endif

void Printer::cmdSetFilSensorCal(float cal) {

#if defined(HASFILAMENTSENSOR)
    filamentSensor.setFilSensorCalibration(cal);
#endif
}

// void Printer::cmdSetStepsPerMME(uint16_t steps) {

// #if defined(HASFILAMENTSENSOR)
    // filamentSensor.setStepsPerMME(steps);
// #endif
// }

#if defined(USEExtrusionRateTable)
void Printer::cmdGetTempTable() {

    txBuffer.sendResponseStart(CmdGetTempTable);

    txBuffer.sendResponseUInt16(extrusionLimitBaseTemp);

    txBuffer.sendResponseUint8(NExtrusionLimit);

    for (uint8_t i=0; i<NExtrusionLimit; i++) {
        txBuffer.sendResponseUInt16(tempExtrusionRateTable[i]);
    }

    txBuffer.sendResponseEnd();
}

void Printer::cmdSetTempTable() {

    extrusionLimitBaseTemp = serialPort.readUInt16NoCheckCobs();

    uint8_t len = serialPort.readNoCheckCobs();
    if (len != NExtrusionLimit) {

        txBuffer.sendSimpleResponse(CmdSetTempTable, RespInvalidArgument);
        return;
    }

    for (uint8_t i=0; i<NExtrusionLimit; i++) {
        tempExtrusionRateTable[i] = serialPort.readUInt16NoCheckCobs();
    }

    txBuffer.sendSimpleResponse(CmdSetTempTable, RespOK);
}
#endif

void Printer::cmdReadGpio(uint8_t pinNumber) {

    // Set pin to input
    HAL_SET_INPUT_PU(pinNumber);

    // Read pin
    uint32_t val = HAL_READ(pinNumber);

    txBuffer.sendResponseStart(CmdReadGpio);
    txBuffer.sendResponseUInt32(val);
    txBuffer.sendResponseEnd();
}

void Printer::cmdReadAnalogGpio(uint8_t pinNumber) {

    // Set pin to analog input
    HAL_SET_INPUT_ANALOG(pinNumber);

    // Read pin
    uint32_t val = HAL_READ_ANALOG(pinNumber);

    txBuffer.sendResponseStart(CmdReadAnalogGpio);
    txBuffer.sendResponseUInt32(val);
    txBuffer.sendResponseEnd();
}

void Printer::cmdSetGpio(uint8_t pinNumber, uint8_t value) {

    // Set pin to input
    HAL_SET_OUTPUT(pinNumber);

    // Set pin
    HAL_WRITE(pinNumber, value);
}

#if defined(POWER_BUTTON)
void Printer::checkPowerOff(unsigned long m) {

    //
    // Check for power-off request
    //
    if (POWER_BUTTON :: active()) {
        if (! powerOffTime) {
            // Power off if power button is held for 3 seconds
            powerOffTime = m + 2000;
        }
    }
    else {
        if (powerOffTime) {
            if (m > powerOffTime) {
                // WRITE(POWER_SUPPLY_RELAY, LOW);
                POWER_SUPPLY_RELAY :: deActivate();
            }
            else {
                powerOffTime = 0;
            }
        }
    }
}
#endif

bool Printer::stepsAvailable() {

    return sDReader.available();
}

Printer printer;

class UsbCommand : public Protothread {
    public:

        // Result of waitForSerial()
        typedef enum {
            NothingAvailable,       // 
            CharsAvailable,       // 
            SerTimeout
            } SerAvailableState;

        // Timestamp of start character of a usbserial command, to
        // detect timeout's.
        unsigned long startTS;

        // Command serial number [1..255]
        uint8_t serialNumber;

        uint8_t commandByte;

        // Computed checksum
        uint16_t checksum;

        // Number of characters we have to read
        uint8_t payloadLength;

        unsigned long drainEnd;

        UsbCommand() {
            serialNumber = 1;
            drainEnd = 0;
        }

        // war blokierend für 50 ms, kehrt nun sofort zurück...
        void reset() {

            // Drain usbserial buffers for 50 ms
            // unsigned long drainEnd = millis() + 50;
            // drainEnd = millis() + 50;
            drainEnd = millis() + 10;
            // while (millis() < drainEnd) {
                serialPort.ringBufferInit();
            // }
        }

        // war blokierend für 50 ms, kehrt nun sofort zurück...
        void crcError() {

            txBuffer.sendSimpleResponse(RespRXCRCError, serialNumber);
            reset();
        }

        // war blokierend für 50 ms, kehrt nun sofort zurück...
        void serialNumberError() {

            txBuffer.sendSimpleResponse(RespSerNumberError, serialNumber);
            reset();
        }

        //
        // Check if serial chars are available.
        //
        FWINLINE SerAvailableState waitForSerial(uint8_t nChars) {

            //
            // If a serial char gets lost, we have a deadlock situation: Firmware waits
            // for more characters to arrive and host application waits for
            // the acknowledge of the last sent command.
            //
            // To prevent this we implement a timeout here.
            //

            unsigned long ts = millis();

            if ((drainEnd > 0) && (ts < drainEnd)) {
                serialPort.ringBufferInit();
                return NothingAvailable;
            }
            drainEnd = 0;

            if (serialPort.size() >= nChars) {

                startTS = ts; // reset timeout 
                return CharsAvailable;
            }

            if ((ts - startTS) > 2500) {

                // XXXXXXXXXXXXX undo: txBuffer.sendSimpleResponse(RespRXTimeoutError, serialNumber);
                reset();
                return SerTimeout;
            }

            return NothingAvailable;
        }


        bool Run() {

            PT_BEGIN();

            uint8_t c, flags, cs1, cs2;

            SerAvailableState av;

            // if ((drainEnd > 0) && (millis() < drainEnd)) {
                // serialPort.flush0();
                // PT_RESTART();   // does a return
            // }
            // drainEnd = 0;

            // Read startbyte
            PT_WAIT_UNTIL( serialPort.size() && ( serialPort.readNoCheckNoCobs() == SOH ) );
            
            startTS = millis();

            checksum = 0xffff;

            // Read packet number, command and payload length
            PT_WAIT_WHILE( (av = waitForSerial(3)) == NothingAvailable );
            if (av == SerTimeout)
                PT_RESTART();

            // Packet serial number
            c = serialPort.readNoCheckNoCobs();
            checksum = _crc_ccitt_update(checksum, c);

            // Read command byte
            commandByte = serialPort.readNoCheckNoCobs();
            checksum = _crc_ccitt_update(checksum, commandByte);

            if (commandByte < 128) {

                //
                // Buffered command
                //
                if (c != serialNumber) {

                    serialNumberError();
                    PT_RESTART();   // does a return
                }

                // Read payload length 1 byte
                payloadLength = serialPort.readNoCheckNoCobs();
                checksum = _crc_ccitt_update(checksum, payloadLength);
                payloadLength--;

                // Wait for payload, checksum flags and two checksum bytes
                PT_WAIT_WHILE( (av = waitForSerial(payloadLength+3)) == NothingAvailable );
                if (av == SerTimeout)
                    PT_RESTART();

                serialPort.peekChecksum(&checksum, payloadLength);

                flags = serialPort.peekN(payloadLength);
                cs1 = serialPort.peekN(payloadLength+1);
                cs2 = serialPort.peekN(payloadLength+2);

                if (! checkCrc(flags, cs1, cs2, checksum)) {
                    PT_RESTART();   // does a return
                }

                if ((commandByte != CmdBlock) && (commandByte != CmdBlockPacked)) {

                    swapDev.addByte(commandByte);
                    PT_WAIT_WHILE( swapDev.isBusyWritingForWrite() );
                }

                // Tell RxBuffer that it's pointing to the beginning of a COBS block
                serialPort.cobsInit(payloadLength);

                if ( (commandByte == CmdG1Packed) || (commandByte == CmdG1RawPacked) || (commandByte == CmdBlockPacked) ) {

                    //
                    // Compressed block
                    //
                    // Stream data block from serial through unzip and store
                    // result on mass storage device.
/*
    #define PT_SPAWN(child) \
        do { (child).Restart(); PT_WAIT_THREAD(child); } while (0)
    PT_WAIT_THREAD(child) PT_WAIT_WHILE((child).Run())
    PT_WAIT_WHILE(condition) PT_WAIT_UNTIL(!(condition))
    
    #define PT_WAIT_UNTIL(condition) \
        do { _ptLine = __LINE__; case __LINE__: \
        if (!(condition)) return true; } while (0)
*/
                    PT_SPAWN(unZipper);

                    /*
unzipper.Restart()
...
    if unzipper.Run() return true;


*/

                }
                else {
                    //
                    // Block not compressed
                    //
                    while (serialPort.cobsAvailable()) {
                        c = serialPort.readNoCheckCobs();
                        swapDev.addByte(c);
                        PT_WAIT_WHILE( swapDev.isBusyWritingForWrite() );
                    }
                }

                // Successfully received command, increment command counter
                serialNumber++;
                if (serialNumber==0)
                    serialNumber = 1;

#if defined(HEAVYDEBUG)
                massert(serialPort.size() == 3);
#endif

                serialPort.ringBufferInit(); // clear rx buffer

                // USBACK;
                txBuffer.sendACK();
            }
            else {

                // 
                // Direct command
                // 
                if ((c != serialNumber) && (commandByte != CmdResetLineNr)) {

                    serialNumberError();
                    PT_RESTART();   // does a return
                }

                // Read payload length 1 byte
                payloadLength = serialPort.readNoCheckNoCobs();
                checksum = _crc_ccitt_update(checksum, payloadLength);
                payloadLength--;

                // Wait for payload, checksum flags and two checksum bytes
                PT_WAIT_WHILE( (av = waitForSerial(payloadLength+3)) == NothingAvailable );
                if (av == SerTimeout)
                    PT_RESTART();

                serialPort.peekChecksum(&checksum, payloadLength);

                flags = serialPort.peekN(payloadLength);
                cs1 = serialPort.peekN(payloadLength+1);
                cs2 = serialPort.peekN(payloadLength+2);

                if (! checkCrc(flags, cs1, cs2, checksum))
                    PT_RESTART();   // does a return

                // Handle ResetLineNr command, set command counter
                if (commandByte == CmdResetLineNr) {
                    serialNumber = 1;
                }

                // Successfully received command, increment command counter
                serialNumber++;
                if (serialNumber==0)
                    serialNumber = 1;

                // Tell RxBuffer that it's pointing to the beginning of a COBS block
                serialPort.cobsInit(payloadLength);

#if defined(HEAVYDEBUG)
                uint8_t bytesLeft = 3;
#endif

                // Handle direct command
                switch (commandByte) {
                    //
                    // Simple ack commands, just one byte, no payload
                    //
                    case CmdResetLineNr:
                        txBuffer.sendACK();
                        break;
                    case CmdDisableSteppers:
                        printer.cmdDisableSteppers();
                        txBuffer.sendACK();
                        break;
                    case CmdPrinterInit:
                        printer.printerInit();
                        txBuffer.sendACK();
                        break;
                    case CmdMove: // move
                        printer.cmdMove((Printer::MoveType)serialPort.readNoCheckCobs());
                        txBuffer.sendACK();
                        break;
                    case CmdEOT: // EOT
                        printer.cmdEot();
                        txBuffer.sendACK();
                        break;
                    case CmdSetHomePos:
                        //
                        // Following call does NOT work - oder of argument evaluation
                        // is unspecified:
                        //
                        /*
                        printer.setHomePos(
                                serialPort.serReadInt32(),
                                serialPort.serReadInt32(),
                                serialPort.serReadInt32());
                        */
                        {
                            int32_t x = serialPort.readInt32NoCheckCobs();
                            int32_t y = serialPort.readInt32NoCheckCobs();
                            int32_t z = serialPort.readInt32NoCheckCobs();

                            // consume two additional ints
                            serialPort.readInt32NoCheckCobs();
                            serialPort.readInt32NoCheckCobs();

                            printer.setHomePos(x, y, z);
                            txBuffer.sendACK();
                        }
                        break;
                    case CmdSetTargetTemp:
                        {
                            uint8_t heater = serialPort.readNoCheckCobs();
                            uint16_t temp = serialPort.readUInt16NoCheckCobs();
                            printer.cmdSetTargetTemp(heater, temp);
                            txBuffer.sendACK();
                        }
                        break;
                    case CmdSetTempPWM:
                        {
                            uint8_t heater = serialPort.readNoCheckCobs();
                            uint8_t pwm = serialPort.readNoCheckCobs();
                            tempControl.setTempPWM(heater, pwm);
                            txBuffer.sendACK();
                        }
                        break;
                    case CmdStopMove:
                        printer.cmdStopMove();
                        txBuffer.sendACK();
                        break;
                    case CmdSoftStop:
                        fillBufferTask.requestSoftStop();
                        txBuffer.sendACK();
                        break;
                    case CmdFanSpeed:
                        printer.cmdFanSpeed(serialPort.readNoCheckCobs(), 0);
                        txBuffer.sendACK();
                        break;
#if defined(PIDAutoTune)
                    // todo: use CmdSetTempPWM
                    case CmdSetHeaterY:
                        {
                            uint8_t heater = serialPort.readNoCheckCobs();
                            uint8_t pwmValue = serialPort.readNoCheckCobs();
                            tempControl.setHeaterY(heater, pwmValue);
                            txBuffer.sendACK();
                        }
                        break;
#endif
#if defined(HASFILAMENTSENSOR)
                    case CmdEnableFRLimit:
                        filamentSensor.enableFeedrateLimiter(serialPort.readNoCheckCobs());
                        txBuffer.sendACK();
                        break;
#endif

                    case CmdSetContTimer:
                        stepBuffer.setContinuosTimer(serialPort.readUInt16NoCheckCobs());
                        txBuffer.sendACK();
                        break;
                    case CmdContinuousE:
                        printer.cmdContinuousE(serialPort.readUInt16NoCheckCobs());
                        txBuffer.sendACK();
                        break;
                    case CmdSetFilSensorCal: {
                        float value = serialPort.readFloatNoCheckCobs();
                        printer.cmdSetFilSensorCal(value);
                        txBuffer.sendACK();
                        }
                        break;
                    // case CmdSetStepsPerMME: {
                        // uint16_t steps = serialPort.readUInt16NoCheckCobs();
                        // printer.cmdSetStepsPerMME(steps);
                        // txBuffer.sendACK();
                        // }
                        // break;
#if defined(__arm__)
                    case CmdBootBootloader:
                        timer.startBootloaderTimer();
                        txBuffer.sendACK();
                        break;
#endif
                    case CmdReadGpio: {
                        uint8_t pinNumber = serialPort.readNoCheckCobs();
                        printer.cmdReadGpio(pinNumber);
                        }
                        break;
                    case CmdReadAnalogGpio: {
                        uint8_t pinNumber = serialPort.readNoCheckCobs();
                        printer.cmdReadAnalogGpio(pinNumber);
                        }
                        break;
                    case CmdSetGpio: {
                        uint8_t pinNumber = serialPort.readNoCheckCobs();
                        uint8_t value = serialPort.readNoCheckCobs();
                        printer.cmdSetGpio(pinNumber, value);
                        txBuffer.sendACK();
                        }
                        break;

                    //
                    // Commands with response payload
                    //
#if 0
                    case CmdGetDirBits:
                        printer.cmdGetDirBits();
                        break;
#endif
                    case CmdGetStatus:
                        printer.cmdGetStatus();
                        break;
                    case CmdGetTaskStatus:
                        printer.cmdGetTaskStatus();
                        break;
                    case CmdGetIOStats:
                        printer.cmdGetIOStats();
                        break;
                    case CmdSetPrinterName: {
                        uint8_t len = serialPort.readNoCheckCobs();
                        char name[64];
                        for (c=0; c<64 && c<len; c++) {
                            name[c] = serialPort.readNoCheckCobs();
                        }
                        printer.cmdSetPrinterName(name, len);
                        }
                        break;
                    case CmdGetPrinterName:
                        printer.cmdGetPrinterName();
                        break;
                    case CmdGetHomed:
                        printer.cmdGetHomed();
                        break;
                    case CmdGetEndstops:
                        printer.cmdGetEndstops();
                        break;
                    case CmdGetPos:
                        printer.cmdGetPos();
                        break;
                    case CmdGetTargetTemps:
                        printer.cmdGetTargetTemps();
                        break;
                    case CmdGetCurrentTemps:
                        printer.cmdGetCurrentTemps();
                        break;
                    case CmdGetTempTable:
                        printer.cmdGetTempTable();
                        break;
                    case CmdSetTempTable:
                        printer.cmdSetTempTable();
                        break;
#if defined(HASFILAMENTSENSOR)
                    case CmdGetFilSensor:
                        printer.cmdGetFilSensor();
                        break;
#endif

#if 0
// Currently not used:
                    case CmdDisableStepperIsr:
                        printer.cmdDisableStepperIsr();
                        break;
#endif

#if defined(DDSim)
                    case CmdExit:
                        printf("CmdExit received, exiting...\n");
                        exit(0);
                        break;
#endif

                    case CmdSetPIDValues: {
                            float Kp = serialPort.readFloatNoCheckCobs();
                            float Ki = serialPort.readFloatNoCheckCobs();
                            float Kd = serialPort.readFloatNoCheckCobs();
                            uint16_t Tu = serialPort.readUInt16NoCheckCobs();
                            printer.cmdSetPIDValues(Kp, Ki, Kd, Tu);
                            txBuffer.sendACK();
                        }
                        break;

                    case CmdSetStepsPerMM: {
                            uint16_t spmmX = serialPort.readUInt16NoCheckCobs();
                            uint16_t spmmY = serialPort.readUInt16NoCheckCobs();
                            uint16_t spmmZ = serialPort.readUInt16NoCheckCobs();
                            printer.cmdSetStepsPerMM(spmmX, spmmY, spmmZ);
                            txBuffer.sendACK();
                        }
                        break;

                    case CmdSetHostSettings:
                            hostSettings.buildVolX = serialPort.readUInt32NoCheckCobs();
                            hostSettings.buildVolY = serialPort.readUInt32NoCheckCobs();
                            hostSettings.buildVolZ = serialPort.readUInt32NoCheckCobs();
                            txBuffer.sendACK();
                        break;

                    case CmdSystemReset:
                        timer.startResetTimer();
                        txBuffer.sendACK();
                        break;

                    case CmdSetIncTemp: {
                            uint8_t heater = serialPort.readNoCheckCobs();
                            int16_t incTemp = serialPort.readInt16NoCheckCobs();
                            printer.cmdSetIncTemp(heater, incTemp);
                            txBuffer.sendACK();
                        }
                        break;

                    case CmdGetFreeMem:
                        printer.cmdGetFreeMem();
                        break;

                    case CmdGetFSReadings: {
                        // uint8_t nReadings = serialPort.readNoCheckCobs();
                        // printer.cmdGetFSReadings(nReadings);
                        printer.cmdGetFSReadings(10);
                        }
                        break;

                    default:
                        txBuffer.sendSimpleResponse(RespUnknownCommand, commandByte);
                        #if defined(HEAVYDEBUG)
                        bytesLeft = serialPort.size();
                        #endif
                }

                #if defined(HEAVYDEBUG)
                massert(serialPort.size() == bytesLeft);
                #endif

                serialPort.ringBufferInit(); // clear rx buffer
            }

            PT_RESTART();
            PT_END();
        }

        // Check checksum, do errorhandling if mismatch
        bool checkCrc(uint8_t flags, uint8_t cs1, uint8_t cs2, uint16_t computedCrc) {

            // 
            //  0x1: (x, y) -> (x, y)
            //  0x2: (0, y) -> (1, y)
            //  0x3: (x, 0) -> (x, 1)
            //  0x4: (0, 0) -> (1, 1)
            // 
            switch (flags) {
                    case 0x2:
                        cs2 &= ~0x1;
                        break;
                    case 0x3:
                        cs1 &= ~0x1;
                        break;
                    case 0x4:
                        cs1 &= ~0x1;
                        cs2 &= ~0x1;
                        break;
            }

            if ((((uint16_t)cs2<<8)|cs1) != computedCrc) {

                    // printf("Checksum Error: 0x%x, computed: 0x%x\n", (cs2<<8)|cs1,  computedCrc);
                    crcError();
                    return false;
            }

            return true;
        }
};

static UsbCommand usbCommand;

#if defined(AVR)
FWINLINE
#endif
void loop() {

    TaskEnd(taskTiming, TaskIdle);

    unsigned long m = millis();

    // Timer for slow running tasks (temp, encoder)
    static unsigned long timer10mS = m + TIMER10MS;
    static unsigned long timer100mS = m + TIMER100MS;
    // static unsigned long timerBufferLow = m;

    TaskStart(taskTiming, TaskSum);

    m = millis();

    if (m >= timer10mS) { // Every 10 mS

        timer10mS = m + TIMER10MS;

        // Check hardware and software endstops:
        if (printer.moveType == Printer::MoveTypeNormal) {

            if (X_STOP_PIN :: active() || Y_STOP_PIN :: active() || Z_STOP_PIN :: active()) {

                LCDMSGKILL(RespHardwareEndstop, "", "");
                txBuffer.sendResponseStart(RespKilled);
                txBuffer.sendResponseUint8(RespHardwareEndstop);
                txBuffer.sendResponseBlob((uint8_t*)current_pos_steps, 3*sizeof(int32_t));
                txBuffer.sendResponseUint8(X_STOP_PIN :: active());
                txBuffer.sendResponseUint8(Y_STOP_PIN :: active());
                txBuffer.sendResponseUint8(Z_STOP_PIN :: active());
                txBuffer.sendResponseEnd();
                kill();
            }
            else if (X_SW_ENDSTOP_PRESSED || Y_SW_ENDSTOP_PRESSED || Z_SW_ENDSTOP_PRESSED) {

                LCDMSGKILL(RespSoftwareEndstop, "", "");
                txBuffer.sendResponseStart(RespKilled);
                txBuffer.sendResponseUint8(RespSoftwareEndstop);
                txBuffer.sendResponseBlob((uint8_t*)current_pos_steps, 3*sizeof(int32_t));
                txBuffer.sendResponseUint8(X_SW_ENDSTOP_PRESSED);
                txBuffer.sendResponseUint8(Y_SW_ENDSTOP_PRESSED);
                txBuffer.sendResponseUint8(Z_SW_ENDSTOP_PRESSED);
                txBuffer.sendResponseEnd();
                kill();
            }
        }

        //
        // Measure temperatures every 10ms
        //
        TaskStart(taskTiming, TaskTempControl);
        tempControl.Run();
        TaskEnd(taskTiming, TaskTempControl);

        //
        // Check new temperature and turn on hotend fan
        //
        printer.runHotEndFan();

        // Run timer
        timer.run(m);
    }

    m = millis();
    if (m >= timer100mS) { // Every 100 mS

        timer100mS = m + TIMER100MS;

        //
        // Control heater 
        //
        TaskStart(taskTiming,  TaskHeater);
        tempControl.heater();
        TaskEnd(taskTiming,  TaskHeater);


        printer.checkMoveFinished();

#if defined(HASFILAMENTSENSOR)
        // Read filament sensor
        TaskStart(taskTiming, TaskFilSensor);
        filamentSensor.run();
        TaskEnd(taskTiming, TaskFilSensor);
#endif

#if defined(POWER_BUTTON)
        printer.checkPowerOff(m);
#endif

        if (swapDev.getBusyWriting() == 2) {
            swapDev.setBusyWriting(1);
        }
    }

    // Statistics: minimal step buffer watermark
    if (printer.printerState == Printer::StateStart)
        if (! (printer.eotWasReceived() && (swapDev.available()==0))) {

            uint16_t s = stepBuffer.size();

            if (s > printer.minBufferMax) {
                printer.minBuffer = s;
                printer.minBufferMax = s;
            }
            else {
                printer.minBuffer = min((uint32_t)s, printer.minBuffer);
            }
        }

    



    // If printing, then read stepper data from mass storage and push it to
    // the stepper buffer.
    TaskStart(taskTiming, TaskFillBuffer);
    fillBufferTask.Run();
    TaskEnd(taskTiming, TaskFillBuffer);

// debug
  filltrace ft;
  ft.timestamp = m;
  ft.sdsize = stepBuffer.size();

    stepBufferLog .pushWrap(ft);

// end debug

    // Handle USB output
    TaskStart(taskTiming, TaskUsbOutput);
    txBuffer.Run();
    TaskEnd(taskTiming, TaskUsbOutput);

    // Handle USB input
    TaskStart(taskTiming, TaskUsbInput);
    usbCommand.Run();
    TaskEnd(taskTiming, TaskUsbInput);

    // Write stepper data to mass storage
    // if (GetTaskDuration(taskTiming, TaskIdle) <= 2) {
        TaskStart(taskTiming, TaskSwapDev);
        swapDev.Run();
        TaskEnd(taskTiming, TaskSwapDev);
    // }

#if 0
    // Check for buffer underruns. A underrun is a emtpy stepper buffer even if data
    // is available on the swap device. In this case the system can't keep up with
    // the rate at which the stepper data is consumed.
    if (printer.printerState == Printer::StateStart) {

        if (printer.bufferLow == -1) {

            if  (! stepBuffer.empty() )
                printer.bufferLow = 0;
        }
        else {
            if (stepBuffer.empty() &&
                swapDev.available() &&
                (printer.bufferLow < INT16_MAX) &&
                (m > timerBufferLow)) {

                printer.bufferLow++;
                timerBufferLow = m;
                // printDebugInfo();
            }
        }
    }
#endif
    
    TaskEnd(taskTiming, TaskSum);

    TaskStart(taskTiming, TaskIdle);
}


void printDebugInfo() {
#if defined(REPRAP_DISCOUNT_SMART_CONTROLLER)
    lcd.setCursor(0, 0); lcd.print("ser:"); lcd.print(serialPort._available());
    lcd.print("B:"); lcd.print(swapDev.isBusyWritingForWrite());
    lcd.print("WP:"); lcd.print(swapDev.getWritePos());

    lcd.setCursor(0, 1); lcd.print("swd:"); lcd.print(swapDev.available());
    lcd.print("MIL:"); lcd.print(millis()-millis());

    lcd.setCursor(0, 2); lcd.print("sdr:"); lcd.print(sDReader.available());

    lcd.setCursor(0, 3); lcd.print("stb:"); lcd.print(stepBuffer.byteSize());

    // Wait 100 s before reboot
    for (int i=0; i<100000; i++) {
        txBuffer.Run();
        WDT_RESET();
        delay(1);
    }
#endif
}

#if defined(AVR)
int main(void) {

    init();

    setup();

    for (;;) {
        loop();
    }

    return 0;
}
#endif




