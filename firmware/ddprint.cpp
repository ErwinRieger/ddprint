/*
 * This file is part of ddprint - a direct drive 3D printer firmware.
 * 
 * Copyright 2015 erwin.rieger@ibrieger.de
 * 
 * ddprint is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * ddprint is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with ddprint.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 * Todo jennyprinter port:
 * * swapdevice: add sanity test sectorsize != 512 bytes?
 * * usb: some flash sticks seem to hang at getReady cmd (add timeout / testUnitReadyRetry)
 * * cleanup task info stuff
 */

#include <Arduino.h>

#include <limits.h>

#include "crc16.h"

#include "ddprint.h"
#include "rxbuffer.h"
#include "txbuffer.h"
#include "temperature.h"
#include "ddtemp.h"
#include "swapdev.h"
#include "filsensor.h"
#include "ddcommands.h"
#include "ddlcd.h"
#include "stepper.h"

#include "protothreads-cpp/Protothread.h"

//The ASCII buffer for recieving from SD:
#define SD_BUFFER_SIZE 512

// Macro to read scalar types from a buffer
#define FromBuf(typ, adr) ( * ((typ *)(adr)))

#define X_SW_ENDSTOP_PRESSED ((current_pos_steps[X_AXIS] < 0) || (current_pos_steps[X_AXIS] > (int32_t)printer.getHostSettings().buildVolX))
#define Y_SW_ENDSTOP_PRESSED ((current_pos_steps[Y_AXIS] < 0) || (current_pos_steps[Y_AXIS] > (int32_t)printer.getHostSettings().buildVolY))
#define Z_SW_ENDSTOP_PRESSED ((current_pos_steps[Z_AXIS] < 0) || (current_pos_steps[Z_AXIS] > (int32_t)printer.getHostSettings().buildVolZ))

// Debug
#if  defined(DEBUGPROCSTAT)

enum LoopTasks { TaskIdle, TaskTempControl, TaskHeater, TaskFilSensor, TaskUsbInput, TaskUsbOutput, TaskSwapDev, TaskFillBuffer, TaskSum};

static struct TaskTiming taskTiming[9] = { 
    { 0, 0, 0, 0 },         // Idle time between loop() calles
    { 0, 0, 0, 0 },         // Temperature measurement
    { 0, 0, 0, 0 },         // Heater temperature control
    { 0, 0, 0, 0 },         // Filament sensor readings (flowrate measurement)
    { 0, 0, 0, 0 },         // USB input
    { 0, 0, 0, 0 },         // USB output
    { 0, 0, 0, 0 },         // Mass storage IO 
    { 0, 0, 0, 0 },         // Read *swapdev* and fill *stepbuffer*
    { 0, 0, 0, 0 },         // Summary of all these tasks
};
#endif


/////////////////////////////////////////////////////////////////////////////////////
// #if defined(USEExtrusionRateTable)

static int16_t extrusionLimitBaseTemp = 170;

//
// Limit extrusion rate by the hotend temperature.
//
// Generated by snippets/genTempTable.py
static uint16_t tempExtrusionRateTable[NExtrusionLimit];

#if 0

= {
    /* Temp: 170.000000, max flowrate: 0.1 mm³/s, max espeed: 0.0 mm/s, steps/s: 5, steprate: 170587 us, timervalue: */ 65535,
    /* Temp: 171.000000, max flowrate: 0.5 mm³/s, max espeed: 0.2 mm/s, steps/s: 29, steprate: 34117 us, timervalue: */ 65535,
    /* Temp: 172.000000, max flowrate: 0.9 mm³/s, max espeed: 0.4 mm/s, steps/s: 52, steprate: 18954 us, timervalue: */ 37908,
    /* Temp: 173.000000, max flowrate: 1.3 mm³/s, max espeed: 0.5 mm/s, steps/s: 76, steprate: 13122 us, timervalue: */ 26244,
    /* Temp: 174.000000, max flowrate: 1.7 mm³/s, max espeed: 0.7 mm/s, steps/s: 99, steprate: 10034 us, timervalue: */ 20069,
    /* Temp: 175.000000, max flowrate: 2.1 mm³/s, max espeed: 0.9 mm/s, steps/s: 123, steprate: 8123 us, timervalue: */ 16246,
    /* Temp: 176.000000, max flowrate: 2.5 mm³/s, max espeed: 1.0 mm/s, steps/s: 146, steprate: 6823 us, timervalue: */ 13646,
    /* Temp: 177.000000, max flowrate: 2.9 mm³/s, max espeed: 1.2 mm/s, steps/s: 170, steprate: 5882 us, timervalue: */ 11764,
    /* Temp: 178.000000, max flowrate: 3.3 mm³/s, max espeed: 1.4 mm/s, steps/s: 193, steprate: 5169 us, timervalue: */ 10338,
    /* Temp: 179.000000, max flowrate: 3.7 mm³/s, max espeed: 1.5 mm/s, steps/s: 216, steprate: 4610 us, timervalue: */ 9220,
    /* Temp: 180.000000, max flowrate: 4.1 mm³/s, max espeed: 1.7 mm/s, steps/s: 240, steprate: 4160 us, timervalue: */ 8321,
    /* Temp: 181.000000, max flowrate: 4.5 mm³/s, max espeed: 1.9 mm/s, steps/s: 263, steprate: 3790 us, timervalue: */ 7581,
    /* Temp: 182.000000, max flowrate: 4.9 mm³/s, max espeed: 2.0 mm/s, steps/s: 287, steprate: 3481 us, timervalue: */ 6962,
    /* Temp: 183.000000, max flowrate: 5.3 mm³/s, max espeed: 2.2 mm/s, steps/s: 310, steprate: 3218 us, timervalue: */ 6437,
    /* Temp: 184.000000, max flowrate: 5.7 mm³/s, max espeed: 2.4 mm/s, steps/s: 334, steprate: 2992 us, timervalue: */ 5985,
    /* Temp: 185.000000, max flowrate: 6.1 mm³/s, max espeed: 2.5 mm/s, steps/s: 357, steprate: 2796 us, timervalue: */ 5593,
    /* Temp: 186.000000, max flowrate: 6.5 mm³/s, max espeed: 2.7 mm/s, steps/s: 381, steprate: 2624 us, timervalue: */ 5248,
    /* Temp: 187.000000, max flowrate: 6.9 mm³/s, max espeed: 2.9 mm/s, steps/s: 404, steprate: 2472 us, timervalue: */ 4944,
    /* Temp: 188.000000, max flowrate: 7.3 mm³/s, max espeed: 3.0 mm/s, steps/s: 427, steprate: 2336 us, timervalue: */ 4673,
    /* Temp: 189.000000, max flowrate: 7.7 mm³/s, max espeed: 3.2 mm/s, steps/s: 451, steprate: 2215 us, timervalue: */ 4430,
    /* Temp: 190.000000, max flowrate: 8.1 mm³/s, max espeed: 3.4 mm/s, steps/s: 474, steprate: 2106 us, timervalue: */ 4212,
    /* Temp: 191.000000, max flowrate: 8.5 mm³/s, max espeed: 3.5 mm/s, steps/s: 498, steprate: 2006 us, timervalue: */ 4013,
    /* Temp: 192.000000, max flowrate: 8.9 mm³/s, max espeed: 3.7 mm/s, steps/s: 521, steprate: 1916 us, timervalue: */ 3833,
    /* Temp: 193.000000, max flowrate: 9.3 mm³/s, max espeed: 3.9 mm/s, steps/s: 545, steprate: 1834 us, timervalue: */ 3668,
    /* Temp: 194.000000, max flowrate: 9.7 mm³/s, max espeed: 4.0 mm/s, steps/s: 568, steprate: 1758 us, timervalue: */ 3517,
    /* Temp: 195.000000, max flowrate: 10.1 mm³/s, max espeed: 4.2 mm/s, steps/s: 592, steprate: 1688 us, timervalue: */ 3377,
    /* Temp: 196.000000, max flowrate: 10.5 mm³/s, max espeed: 4.4 mm/s, steps/s: 615, steprate: 1624 us, timervalue: */ 3249,
    /* Temp: 197.000000, max flowrate: 10.9 mm³/s, max espeed: 4.5 mm/s, steps/s: 638, steprate: 1565 us, timervalue: */ 3130,
    /* Temp: 198.000000, max flowrate: 11.3 mm³/s, max espeed: 4.7 mm/s, steps/s: 662, steprate: 1509 us, timervalue: */ 3019,
    /* Temp: 199.000000, max flowrate: 11.7 mm³/s, max espeed: 4.9 mm/s, steps/s: 685, steprate: 1458 us, timervalue: */ 2916,
    /* Temp: 200.000000, max flowrate: 12.1 mm³/s, max espeed: 5.0 mm/s, steps/s: 709, steprate: 1409 us, timervalue: */ 2819,
    /* Temp: 201.000000, max flowrate: 12.5 mm³/s, max espeed: 5.2 mm/s, steps/s: 732, steprate: 1364 us, timervalue: */ 2729,
    /* Temp: 202.000000, max flowrate: 12.9 mm³/s, max espeed: 5.4 mm/s, steps/s: 756, steprate: 1322 us, timervalue: */ 2644,
    /* Temp: 203.000000, max flowrate: 13.3 mm³/s, max espeed: 5.5 mm/s, steps/s: 779, steprate: 1282 us, timervalue: */ 2565,
    /* Temp: 204.000000, max flowrate: 13.7 mm³/s, max espeed: 5.7 mm/s, steps/s: 803, steprate: 1245 us, timervalue: */ 2490,
    /* Temp: 205.000000, max flowrate: 14.1 mm³/s, max espeed: 5.9 mm/s, steps/s: 826, steprate: 1209 us, timervalue: */ 2419,
    /* Temp: 206.000000, max flowrate: 14.5 mm³/s, max espeed: 6.0 mm/s, steps/s: 850, steprate: 1176 us, timervalue: */ 2352,
    /* Temp: 207.000000, max flowrate: 14.9 mm³/s, max espeed: 6.2 mm/s, steps/s: 873, steprate: 1144 us, timervalue: */ 2289,
    /* Temp: 208.000000, max flowrate: 15.3 mm³/s, max espeed: 6.4 mm/s, steps/s: 896, steprate: 1114 us, timervalue: */ 2229,
    /* Temp: 209.000000, max flowrate: 15.7 mm³/s, max espeed: 6.5 mm/s, steps/s: 920, steprate: 1086 us, timervalue: */ 2173,
    /* Temp: 210.000000, max flowrate: 16.1 mm³/s, max espeed: 6.7 mm/s, steps/s: 943, steprate: 1059 us, timervalue: */ 2119,
    /* Temp: 211.000000, max flowrate: 16.5 mm³/s, max espeed: 6.9 mm/s, steps/s: 967, steprate: 1033 us, timervalue: */ 2067,
    /* Temp: 212.000000, max flowrate: 16.9 mm³/s, max espeed: 7.0 mm/s, steps/s: 990, steprate: 1009 us, timervalue: */ 2018,
    /* Temp: 213.000000, max flowrate: 17.3 mm³/s, max espeed: 7.2 mm/s, steps/s: 1014, steprate: 986 us, timervalue: */ 1972,
    /* Temp: 214.000000, max flowrate: 17.7 mm³/s, max espeed: 7.4 mm/s, steps/s: 1037, steprate: 963 us, timervalue: */ 1927,
    /* Temp: 215.000000, max flowrate: 18.1 mm³/s, max espeed: 7.5 mm/s, steps/s: 1061, steprate: 942 us, timervalue: */ 1884,
    /* Temp: 216.000000, max flowrate: 18.5 mm³/s, max espeed: 7.7 mm/s, steps/s: 1084, steprate: 922 us, timervalue: */ 1844,
    /* Temp: 217.000000, max flowrate: 18.9 mm³/s, max espeed: 7.9 mm/s, steps/s: 1107, steprate: 902 us, timervalue: */ 1805,
    /* Temp: 218.000000, max flowrate: 19.3 mm³/s, max espeed: 8.0 mm/s, steps/s: 1131, steprate: 883 us, timervalue: */ 1767,
    /* Temp: 219.000000, max flowrate: 19.7 mm³/s, max espeed: 8.2 mm/s, steps/s: 1154, steprate: 865 us, timervalue: */ 1731,
    /* Temp: 220.000000, max flowrate: 20.1 mm³/s, max espeed: 8.4 mm/s, steps/s: 1178, steprate: 848 us, timervalue: */ 1697,
    /* Temp: 221.000000, max flowrate: 20.5 mm³/s, max espeed: 8.5 mm/s, steps/s: 1201, steprate: 832 us, timervalue: */ 1664,
    /* Temp: 222.000000, max flowrate: 20.9 mm³/s, max espeed: 8.7 mm/s, steps/s: 1225, steprate: 816 us, timervalue: */ 1632,
    /* Temp: 223.000000, max flowrate: 21.3 mm³/s, max espeed: 8.9 mm/s, steps/s: 1248, steprate: 800 us, timervalue: */ 1601,
    /* Temp: 224.000000, max flowrate: 21.7 mm³/s, max espeed: 9.0 mm/s, steps/s: 1272, steprate: 786 us, timervalue: */ 1572,
    /* Temp: 225.000000, max flowrate: 22.1 mm³/s, max espeed: 9.2 mm/s, steps/s: 1295, steprate: 771 us, timervalue: */ 1543,
    /* Temp: 226.000000, max flowrate: 22.5 mm³/s, max espeed: 9.4 mm/s, steps/s: 1318, steprate: 758 us, timervalue: */ 1516,
    /* Temp: 227.000000, max flowrate: 22.9 mm³/s, max espeed: 9.5 mm/s, steps/s: 1342, steprate: 744 us, timervalue: */ 1489,
    /* Temp: 228.000000, max flowrate: 23.3 mm³/s, max espeed: 9.7 mm/s, steps/s: 1365, steprate: 732 us, timervalue: */ 1464,
    /* Temp: 229.000000, max flowrate: 23.7 mm³/s, max espeed: 9.9 mm/s, steps/s: 1389, steprate: 719 us, timervalue: */ 1439,
    /* Temp: 230.000000, max flowrate: 24.1 mm³/s, max espeed: 10.0 mm/s, steps/s: 1412, steprate: 707 us, timervalue: */ 1415,
    /* Temp: 231.000000, max flowrate: 24.5 mm³/s, max espeed: 10.2 mm/s, steps/s: 1436, steprate: 696 us, timervalue: */ 1392,
    /* Temp: 232.000000, max flowrate: 24.9 mm³/s, max espeed: 10.4 mm/s, steps/s: 1459, steprate: 685 us, timervalue: */ 1370,
    /* Temp: 233.000000, max flowrate: 25.3 mm³/s, max espeed: 10.5 mm/s, steps/s: 1483, steprate: 674 us, timervalue: */ 1348,
    /* Temp: 234.000000, max flowrate: 25.7 mm³/s, max espeed: 10.7 mm/s, steps/s: 1506, steprate: 663 us, timervalue: */ 1327,
    /* Temp: 235.000000, max flowrate: 26.1 mm³/s, max espeed: 10.9 mm/s, steps/s: 1530, steprate: 653 us, timervalue: */ 1307,
    /* Temp: 236.000000, max flowrate: 26.5 mm³/s, max espeed: 11.0 mm/s, steps/s: 1553, steprate: 643 us, timervalue: */ 1287,
    /* Temp: 237.000000, max flowrate: 26.9 mm³/s, max espeed: 11.2 mm/s, steps/s: 1576, steprate: 634 us, timervalue: */ 1268,
    /* Temp: 238.000000, max flowrate: 27.3 mm³/s, max espeed: 11.4 mm/s, steps/s: 1600, steprate: 624 us, timervalue: */ 1249,
    /* Temp: 239.000000, max flowrate: 27.7 mm³/s, max espeed: 11.5 mm/s, steps/s: 1623, steprate: 615 us, timervalue: */ 1231,
    /* Temp: 240.000000, max flowrate: 28.1 mm³/s, max espeed: 11.7 mm/s, steps/s: 1647, steprate: 607 us, timervalue: */ 1214,
    /* Temp: 241.000000, max flowrate: 28.5 mm³/s, max espeed: 11.8 mm/s, steps/s: 1670, steprate: 598 us, timervalue: */ 1197,
    /* Temp: 242.000000, max flowrate: 28.9 mm³/s, max espeed: 12.0 mm/s, steps/s: 1694, steprate: 590 us, timervalue: */ 1180,
    /* Temp: 243.000000, max flowrate: 29.3 mm³/s, max espeed: 12.2 mm/s, steps/s: 1717, steprate: 582 us, timervalue: */ 1164,
    /* Temp: 244.000000, max flowrate: 29.7 mm³/s, max espeed: 12.3 mm/s, steps/s: 1741, steprate: 574 us, timervalue: */ 1148,
    /* Temp: 245.000000, max flowrate: 30.1 mm³/s, max espeed: 12.5 mm/s, steps/s: 1764, steprate: 566 us, timervalue: */ 1133,
    /* Temp: 246.000000, max flowrate: 30.5 mm³/s, max espeed: 12.7 mm/s, steps/s: 1787, steprate: 559 us, timervalue: */ 1118,
    /* Temp: 247.000000, max flowrate: 30.9 mm³/s, max espeed: 12.8 mm/s, steps/s: 1811, steprate: 552 us, timervalue: */ 1104,
    /* Temp: 248.000000, max flowrate: 31.3 mm³/s, max espeed: 13.0 mm/s, steps/s: 1834, steprate: 545 us, timervalue: */ 1090,
    /* Temp: 249.000000, max flowrate: 31.7 mm³/s, max espeed: 13.2 mm/s, steps/s: 1858, steprate: 538 us, timervalue: */ 1076,
    /* Temp: 250.000000, max flowrate: 32.1 mm³/s, max espeed: 13.3 mm/s, steps/s: 1881, steprate: 531 us, timervalue: */ 1062,
    /* Temp: 251.000000, max flowrate: 32.5 mm³/s, max espeed: 13.5 mm/s, steps/s: 1905, steprate: 524 us, timervalue: */ 1049,
    /* Temp: 252.000000, max flowrate: 32.9 mm³/s, max espeed: 13.7 mm/s, steps/s: 1928, steprate: 518 us, timervalue: */ 1037,
    /* Temp: 253.000000, max flowrate: 33.3 mm³/s, max espeed: 13.8 mm/s, steps/s: 1952, steprate: 512 us, timervalue: */ 1024,
    /* Temp: 254.000000, max flowrate: 33.7 mm³/s, max espeed: 14.0 mm/s, steps/s: 1975, steprate: 506 us, timervalue: */ 1012,
    /* Temp: 255.000000, max flowrate: 34.1 mm³/s, max espeed: 14.2 mm/s, steps/s: 1998, steprate: 500 us, timervalue: */ 1000,
    /* Temp: 256.000000, max flowrate: 34.5 mm³/s, max espeed: 14.3 mm/s, steps/s: 2022, steprate: 494 us, timervalue: */ 988,
    /* Temp: 257.000000, max flowrate: 34.9 mm³/s, max espeed: 14.5 mm/s, steps/s: 2045, steprate: 488 us, timervalue: */ 977,
    /* Temp: 258.000000, max flowrate: 35.3 mm³/s, max espeed: 14.7 mm/s, steps/s: 2069, steprate: 483 us, timervalue: */ 966,
    /* Temp: 259.000000, max flowrate: 35.7 mm³/s, max espeed: 14.8 mm/s, steps/s: 2092, steprate: 477 us, timervalue: */ 955,
    /* Temp: 260.000000, max flowrate: 36.1 mm³/s, max espeed: 15.0 mm/s, steps/s: 2116, steprate: 472 us, timervalue: */ 945,
    /* Temp: 261.000000, max flowrate: 36.5 mm³/s, max espeed: 15.2 mm/s, steps/s: 2139, steprate: 467 us, timervalue: */ 934,
    /* Temp: 262.000000, max flowrate: 36.9 mm³/s, max espeed: 15.3 mm/s, steps/s: 2163, steprate: 462 us, timervalue: */ 924,
    /* Temp: 263.000000, max flowrate: 37.3 mm³/s, max espeed: 15.5 mm/s, steps/s: 2186, steprate: 457 us, timervalue: */ 914,
    /* Temp: 264.000000, max flowrate: 37.7 mm³/s, max espeed: 15.7 mm/s, steps/s: 2210, steprate: 452 us, timervalue: */ 904,
    /* Temp: 265.000000, max flowrate: 38.1 mm³/s, max espeed: 15.8 mm/s, steps/s: 2233, steprate: 447 us, timervalue: */ 895,
    /* Temp: 266.000000, max flowrate: 38.5 mm³/s, max espeed: 16.0 mm/s, steps/s: 2256, steprate: 443 us, timervalue: */ 886,
    /* Temp: 267.000000, max flowrate: 38.9 mm³/s, max espeed: 16.2 mm/s, steps/s: 2280, steprate: 438 us, timervalue: */ 877,
    /* Temp: 268.000000, max flowrate: 39.3 mm³/s, max espeed: 16.3 mm/s, steps/s: 2303, steprate: 434 us, timervalue: */ 868,
    /* Temp: 269.000000, max flowrate: 39.7 mm³/s, max espeed: 16.5 mm/s, steps/s: 2327, steprate: 429 us, timervalue: */ 859,
};
#endif
// #endif

/////////////////////////////////////////////////////////////////////////////////////


void printDebugInfo();

void kill() {

    CLI(); // Stop interrupts
    disable_heater();

    printer.disableSteppers();

    // printDebugInfo();

    txBuffer.flush(true);

    for (int i=0; i<1000; i++) {
        delay(1);
        WDT_RESET();
    }

#if defined(POWER_SUPPLY_RELAY)
    POWER_SUPPLY_RELAY :: saveState();
#endif
}

void mAssert(uint16_t line, const char* file) {

    noInterrupts();
    disable_heater();
    st_disableSteppers();

    LCDMSGKILL(RespAssertion, line, file);

    txBuffer.flush();
    txBuffer.sendResponseStart(RespKilled);
    txBuffer.sendResponseUint8(RespAssertion);
    txBuffer.sendResponseUInt16(line);
    txBuffer.sendResponseString(file, strlen(file));
    txBuffer.sendResponseEnd();
    kill();
}

void killMessage(uint8_t errorCode, uint8_t errorParam /*, const char *msg */) {

    LCDMSGKILL(errorCode, errorParam, "");
    txBuffer.sendSimpleResponse(RespKilled, errorCode, errorParam);
    kill();
}

void killMessage(uint8_t errorCode, uint8_t errorParam1, uint8_t errorParam2 /* , const char *msg */) {

    LCDMSGKILL(errorCode, errorParam1, "");
    txBuffer.sendSimpleResponse(RespKilled, errorCode, errorParam1, errorParam2);
    kill();
}

// debug
void genericIntMessage(int32_t msg) {
    printer.sendGenericInt32(msg);
}

void setup() {

#if defined(REPRAP_DISCOUNT_SMART_CONTROLLER)
    lcd.setCursor(0, 0); 
    lcd.print("OK");
#endif

    CLI();

    // No watchdog for debugging, dangerous!   
#if !defined(DEBUGVERSION) 
    WDT_ENABLE();
#endif

    TIMER_INIT();

#if defined(POWER_SUPPLY_RELAY)
    // Switch on power relais to keep power
    POWER_SUPPLY_RELAY :: initActive();
#endif

#if defined(HOTEND_FAN_PIN)
    HOTEND_FAN_PIN :: initDeActive();
#endif

#if defined(MB_FAN_PIN)
    MB_FAN_PIN :: initDeActive();
#endif

#if defined(POWER_BUTTON)
    POWER_BUTTON :: init();
#endif

#if defined(LED_PIN)
    LED_PIN :: init();
#endif

    FAN_PIN :: init();

#if defined(MIN_FAN_PWM)
    // For printers where the mainboard cooling fan is connected
    // to the parts cooling fan. Keep mainboard fan running.
    printer.cmdFanSpeed(MIN_FAN_PWM, 100);
#endif

    HAL_SPI_INIT();

    rxBuffer.begin(BAUDRATE);

    tp_init();    // Initialize temperature loop

    st_init();    // Initialize stepper

#if defined(LED_PIN)
    LED_PIN :: write(255 * 0.5);
#endif

    HAL_IRQ_INIT();

    SEI();

    uint8_t retry;
    for (retry=0; retry<5; retry++) {

        if (swapDev.swapInit()) {
            break;
        }

        printer.sendGenericInt32(swapDev.errorCode()); // debug
        txBuffer.flush(true);

        WDT_RESET();
        delay(3000);
    }

    if (retry == 5) {
        LCDMSGKILL(RespSDInit, "swapInit()", "");
        txBuffer.sendSimpleResponse(RespKilled, RespSDInit);
        kill();
    }

    TaskStart(taskTiming, TaskIdle);
}

//
// SDReader, read buffered stepdata from swapdevice
//

// Block-buffered sd read
class SDReader: public Protothread {

    // Buffer for block-wise reading of swap memory
    // uint8_t buffer[SD_BUFFER_SIZE];
    uint8_t *buffer;

    // Number of characters in buffer
    int16_t bufferLength;

    // Readpointer into buffer
    uint16_t bufferPtr;

    // Number of bytes to read on current thread run
    // uint16_t bytesToRead;
    uint8_t bytesToRead;

    // Temporary buffer if we cross a block boundary,
    // the size is 4 bytes - the length of the longest
    // datablock to read (see setBytesToReadX())
    uint8_t tempBuffer[4]; 

    uint16_t haveBytes;


    public:

    // Pointer to the result data, points into buffer directly or
    // to tempBuffer.
    uint8_t *readData;

    SDReader() {
        bufferLength = 0;
        bufferPtr = 0;
    }

    FWINLINE void setBytesToRead1() {
        Restart();
        bytesToRead = 1; } // Note: tempBuffer must be big enought to hold this number of bytes.
    FWINLINE void setBytesToRead2() {
        Restart();
        bytesToRead = 2; } // Note: tempBuffer must be big enought to hold this number of bytes.
    FWINLINE void setBytesToRead3() {
        Restart();
        bytesToRead = 3; } // Note: tempBuffer must be big enought to hold this number of bytes.
    FWINLINE void setBytesToRead4() {
        Restart();
        bytesToRead = 4; } // Note: tempBuffer must be big enought to hold this number of bytes.

    bool Run() {

        uint8_t i;

        PT_BEGIN();

        simassert((bytesToRead > 0) && (bytesToRead<5));
        simassert(bufferPtr <= bufferLength);

        haveBytes = bufferLength - bufferPtr;

        if (haveBytes < bytesToRead) {

            //
            // Read data from swap memory if not enough data in buffer 
            //
            if (haveBytes) {
                //
                // Copy the last bytes to temp buffer
                //
                for (i=0; i<haveBytes; i++) {
                    tempBuffer[i] = buffer[bufferPtr+i]; 
                    bytesToRead--;
                }

                //
                // Get new block from swapmem
                //
                PT_WAIT_UNTIL(swapDev.cacheFilled);

                bufferLength = swapDev.readBlock();
                buffer = swapDev.readBuffer;

                for (i=0; i<bytesToRead; i++) {
                    tempBuffer[haveBytes+i] = buffer[i]; 
                }

                readData = tempBuffer;
                bufferPtr = bytesToRead;
            }
            else {

                //
                // Buffer empty, get new block from swapmem
                //
                PT_WAIT_UNTIL(swapDev.cacheFilled);

                bufferLength = swapDev.readBlock();
                buffer = swapDev.readBuffer;

                readData = buffer;
                bufferPtr = bytesToRead;
            }

            // massert(bufferLength > 0);
        }
        else {

            // Enough data in buffer to satisfy request
            readData = buffer + bufferPtr;
            bufferPtr += bytesToRead;
        }

        PT_END();
    }

    FWINLINE uint16_t available() {

        simassert(bufferLength >= bufferPtr);
        return bufferLength - bufferPtr;
    }

    uint16_t getBufferPtr() { return bufferPtr; }

    void flush() {

        bufferLength = bufferPtr = 0;

        //
        // Restart is done in setBytesToReadX().
        //
        swapDev.reset();
    }
};

static SDReader sDReader;

class FillBufferTask : public Protothread {

    uint16_t flags;
    uint8_t timerLoop;
    uint16_t lastTimer;

    uint16_t nAccel16;
    uint16_t nAccel8;
    uint8_t leadAxis;
    uint8_t leadAxisBit;
    uint16_t tLin;
    uint16_t nDecel16;
    uint16_t nDecel8;
    int32_t absSteps[5];

    // Bresenham factors
    int32_t d_axis[5];
    int32_t d1_axis[5];
    int32_t d2_axis[5];

    int32_t deltaLead, step32;
    // uint16_t step16;
    uint16_t count;

    // Number of 25 mS nop segments for G4/dwell
    uint16_t nDwell;

    // #if defined(__arm__)
    uint8_t stepsThisRun;
    // #endif

    // bool cmdSync;
    bool stopRequested;

    // #if defined(USEExtrusionRateTable)
    // Scaling factor for timerValues to implement temperature speed limit 
    uint32_t timerScale;
    // Timervalue of max e-speed for this move
    ScaledUInt32    eSpeedTimer;
    bool limiting;
    // #endif

    stepData sd;

    public:
    FillBufferTask() {
        sd.dirBits = 0;
        // cmdSync = false;
        stopRequested = false;
    }

    uint8_t decStepsThisRun() {

        stepsThisRun--;

        if (stepsThisRun == 0) {

            stepsThisRun = (uint8_t)255 - stepBuffer.size();
            return 0;
        }

        return stepsThisRun;
    }

    bool Run() {

        uint8_t i, cmd;

        int32_t d;
        int32_t d1;
        int32_t d2;

        // #if defined(USEExtrusionRateTable)
        uint32_t maxTempSpeed;
        // #endif

        // #if debug...
        // static uint8_t dbgcount=0;

        PT_BEGIN();

#if 0
# Move segment data, new with bresenham in firmware:
#   * Header data:
#       + 8 flag bits
#       + index lead axis, 8 bits
#       + array of absolute steps, 5 * 16 bits
#       + number of accel steps, naccel, 16 bits
#       + constant linear timer value, 16 bits
#       + number of decel steps, ndccel, 16 bits
#
#   * accel steps: naccel*(timer value(16bits)) or 16bits + (naccel-1)*8bits
#
#   * decel steps: ndecel*(timer value(16bits)) or 16bits + (naccel-1)*8bits
#endif

        sDReader.setBytesToRead1();
        PT_WAIT_THREAD(sDReader);
        cmd = *sDReader.readData;

        switch (cmd) {

            case CmdG1:
                // case CmdG1Packed:
                goto HandleCmdG1;

            case CmdG1Raw:
                // case CmdG1RawPacked:
                goto HandleCmdG1Raw;

            case CmdSyncFanSpeed:
                goto HandleCmdSyncFanSpeed;

            case CmdSyncTargetTemp:
                goto HandleCmdSyncTargetTemp;

            case CmdDwellMS:
                goto HandleCmdDwellMS;

            case CmdSuggestPwm:
                goto HandleCmdSuggestPwm;

            case CmdNop:
                goto HandleCmdNop;

            default:
                killMessage(RespUnknownBCommand, cmd);
        }

HandleCmdG1:

        PT_WAIT_WHILE( (stepsThisRun = ((uint8_t)255 - stepBuffer.size())) == 0 );

        // Read flag word and stepper direction bits
        sDReader.setBytesToRead2();
        PT_WAIT_THREAD(sDReader);
        flags = FromBuf(uint16_t, sDReader.readData);

        if (flags & 0x80)
            // Change stepper direction(s)
            sd.dirBits = flags & 0x9F;

        // cmdSync = true;

        // if (flags & MeasureStartBit) // Measurement move
            // sd.dirBits |=  0x40; // Set measurement flag
        // else
            // sd.dirBits &=  ~0x40; // Clear measurement flag

        //
        // Read index of lead axis
        //
        sDReader.setBytesToRead1();
        PT_WAIT_THREAD(sDReader);
        leadAxis = *sDReader.readData;

        leadAxisBit = 1 << leadAxis;

        //
        // Read array of absolute step distances of the 5 axes
        //
        sDReader.setBytesToRead4();
        PT_WAIT_THREAD(sDReader);
        absSteps[0] = FromBuf(int32_t, sDReader.readData);

        sDReader.setBytesToRead4();
        PT_WAIT_THREAD(sDReader);
        absSteps[1] = FromBuf(int32_t, sDReader.readData);

        sDReader.setBytesToRead4();
        PT_WAIT_THREAD(sDReader);
        absSteps[2] = FromBuf(int32_t, sDReader.readData);

        sDReader.setBytesToRead4();
        PT_WAIT_THREAD(sDReader);
        absSteps[3] = FromBuf(int32_t, sDReader.readData);

        sDReader.setBytesToRead4();
        PT_WAIT_THREAD(sDReader);
        absSteps[4] = FromBuf(int32_t, sDReader.readData);

        sDReader.setBytesToRead2();
        PT_WAIT_THREAD(sDReader);
        nAccel16 = FromBuf(uint16_t, sDReader.readData);

        sDReader.setBytesToRead2();
        PT_WAIT_THREAD(sDReader);
        nAccel8 = FromBuf(uint16_t, sDReader.readData);

// #if defined(USEExtrusionRateTable)
        //////////////////////////////////////////////////////
        limiting = false;

        // Check beginning of new base move
        if (flags & 0x100) {

            sDReader.setBytesToRead4();
            PT_WAIT_THREAD(sDReader);
            eSpeedTimer.value = FromBuf(uint32_t, sDReader.readData);

            sDReader.setBytesToRead1();
            PT_WAIT_THREAD(sDReader);
            eSpeedTimer.shift = *sDReader.readData;

            // printf("eSpeedTimer: %d\n", eSpeedTimer);

            if (eSpeedTimer.value > 0) {

                // Lookup this e-speed in the extrusion rate table
                int16_t curTempIndex = fromFWTemp( current_temperature[0] ) - extrusionLimitBaseTemp;

                // printf("curTempIndex: %d\n", curTempIndex);

                if (curTempIndex < 0) {

                    // printf("temp low, use first entry\n");
                    maxTempSpeed = tempExtrusionRateTable[0];
                }
                else if (curTempIndex >= NExtrusionLimit) {

                    // printf("temp high, use last entry\n");
                    maxTempSpeed = tempExtrusionRateTable[NExtrusionLimit-1];
                }
                else {

                    // printf("temp in range\n");
                    maxTempSpeed = tempExtrusionRateTable[curTempIndex];
                }

                // Speed is limited by temperature
                timerScale = min( 
                        (maxTempSpeed * eSpeedTimer.value) >> eSpeedTimer.shift,
                        (uint32_t)(4*1024) );       // scale 1024

                if (timerScale > 1024) {

                    if (filamentSensor.isLimiting()) {

                        // Speed is additionally limited by feeder grip/slip, up to 16 times limit
                        timerScale = (timerScale * filamentSensor.getSlowDown()) >> 10; // scale pow(1024) -> 1024
                        printer.underGrip = min(printer.underGrip+1, 0xffff);

                        // printer.sendGenericInt32(timerScale);
                    }

                    #if ! defined(COLDEXTRUSION)
                    limiting = true;
                    printer.underTemp = min(printer.underTemp+1, 0xffff);
                    #endif
                }
                else {

                    // Speed is not limited by temperature
                    if (filamentSensor.isLimiting()) {

                        timerScale = filamentSensor.getSlowDown();       // scale 1024
                        limiting = true;
                        printer.underGrip = min(printer.underGrip+1, 0xffff);

                        // printer.sendGenericInt32(timerScale);
                    }
                    else if (printer.isLimiting()) {
                        timerScale = printer.getSlowDown();       // scale 1024
                        limiting = true;
                        // dont update statistic value underGrip if in debug/
                        // measurement mode.
                    }
                }
            }
                    // else {
                        // Non-printmove
                        // timerScale = 1.0;
                    // }
        }
// #endif   // #if defined(USEExtrusionRateTable)

// #if defined(HEAVYDEBUG)
                if (limiting) {
                    // if ((dbgcount++ & 0xf) == 0) {
                        // printer.sendGenericInt32(timerScale);
                    // }
                    massert(timerScale >= 512);
                }
                // #endif
                //////////////////////////////////////////////////////

                sDReader.setBytesToRead2();
                PT_WAIT_THREAD(sDReader);

                if (limiting) 
                    tLin = STD min ( 
                        (uint16_t)( ((uint32_t)FromBuf(uint16_t, sDReader.readData) * timerScale) >> 10 ),
                        (uint16_t)0xffff);
                else 
                    tLin = FromBuf(uint16_t, sDReader.readData);

                sDReader.setBytesToRead2();
                PT_WAIT_THREAD(sDReader);
                nDecel8 = FromBuf(uint16_t, sDReader.readData);

                sDReader.setBytesToRead2();
                PT_WAIT_THREAD(sDReader);
                nDecel16 = FromBuf(uint16_t, sDReader.readData);

                //
                // Compute bresenham factors
                //
                deltaLead = absSteps[leadAxis];

                //  d = (2 * deltay) - deltax 
                //    = d1 - deltax
                // d1 = (2 * deltay)
                // d2 = 2 * (deltay - deltax)
                //    = 2 * deltay - 2 * deltax
                //    = d - deltax
                for (i=0; i<5; i++) {

                    if (i == leadAxis)
                        continue;

                    d1 = 2 * absSteps[i];
                    d = d1 - deltaLead;
                    d2 = d - deltaLead;

                    d_axis[i] = d;
                    d1_axis[i] = d1;
                    d2_axis[i] = d2;
                }

                // Counter for constant phase
                step32 = deltaLead - (nAccel16+nAccel8+nDecel8+nDecel16);

                //
                // Acceleration
                //

                // Timer value as 16bit value
                if (nAccel16) {

                    sd.dirBits &=  ~0x40; // Clear linear flag

                    sDReader.setBytesToRead2();
                    PT_WAIT_THREAD(sDReader);

                    if (limiting)
                        sd.timer = STD min (
                                (uint16_t)( ((uint32_t)FromBuf(uint16_t, sDReader.readData) * timerScale) >> 10 ),
                                (uint16_t)0xffff );
                    else
                        sd.timer = FromBuf(uint16_t, sDReader.readData);

                    computeStepBits();

                    // PT_WAIT_WHILE(stepBuffer.enough());

                    PT_WAIT_WHILE(decStepsThisRun() == 0);
                    stepBuffer.pushRef(sd);

                    sd.dirBits &= ~0x80; // clear set-direction bit (after push)

                    // for (step16 = 1; step16 < nAccel16; step16++)
                    if (--nAccel16) do {

                        sDReader.setBytesToRead2();
                        PT_WAIT_THREAD(sDReader);

                        if (limiting)
                            sd.timer = STD min (
                                (uint16_t)( ((uint32_t)FromBuf(uint16_t, sDReader.readData) * timerScale) >> 10 ),
                                (uint16_t)0xffff );
                        else
                            sd.timer = FromBuf(uint16_t, sDReader.readData);

                        computeStepBits();

                        // PT_WAIT_WHILE(stepBuffer.enough());

                        PT_WAIT_WHILE(decStepsThisRun() == 0);
                        stepBuffer.pushRef(sd);

                    } while (--nAccel16);
                }

                // Timer value as 8bit value
                if (nAccel8) {

                    sd.dirBits &=  ~0x40; // Clear linear flag

                    sDReader.setBytesToRead1();
                    PT_WAIT_THREAD(sDReader);

                    if (limiting)
                        sd.timer = STD min (
                            (uint16_t)( ((uint32_t)*sDReader.readData * timerScale) >> 10 ),
                            (uint16_t)0xffff );
                    else
                        sd.timer = *sDReader.readData;

                    computeStepBits();

                    // PT_WAIT_WHILE(stepBuffer.enough());

                    PT_WAIT_WHILE(decStepsThisRun() == 0);
                    stepBuffer.pushRef(sd);

                    sd.dirBits &= ~0x80; // clear set-direction bit (after push)

                    // for (step16 = 1; step16 < nAccel8; step16++)
                    if (--nAccel8) do {

                        sDReader.setBytesToRead1();
                        PT_WAIT_THREAD(sDReader);

                        if (limiting)
                            sd.timer = STD min (
                                (uint16_t)( ((uint32_t)*sDReader.readData * timerScale) >> 10 ),
                                (uint16_t)0xffff );
                        else
                            sd.timer = *sDReader.readData;

                        computeStepBits();

                        // PT_WAIT_WHILE(stepBuffer.enough());

                        PT_WAIT_WHILE(decStepsThisRun() == 0);
                        stepBuffer.pushRef(sd);

                    } while (--nAccel8);
                }

                //
                // Constant phase
                //
                if (step32) {

                    // if (flags & 0x200) // Measurement move
                        // sd.dirBits |=  0x40; // Set linear flag
                    // if (flags & st_get_move_bit_mask<EAxisSelector>())
                        // sd.dirBits |=  0x40; // Set linear flag if E is moving forwards

                    // Set linear flag (start FRS measurement) if E is moving forwards
                    if (sd.dirBits & st_get_move_bit_mask<EAxisSelector>())
                        sd.dirBits |=  0x40;

                    sd.timer = tLin;

                    computeStepBits();

                    // PT_WAIT_WHILE(stepBuffer.enough());

                    PT_WAIT_WHILE(decStepsThisRun() == 0);
                    stepBuffer.pushRef(sd);

                    sd.dirBits &= ~0x80; // clear set-direction bit (after push)

                    if (--step32) do {

                        computeStepBits();

                        // PT_WAIT_WHILE(stepBuffer.enough());

                        PT_WAIT_WHILE(decStepsThisRun() == 0);
                        stepBuffer.pushRef(sd);

                    } while (--step32);
                
                    sd.dirBits &=  ~0x40; // Clear linear flag
                }

                //
                // Deceleration
                //
                
                // Timer value as 8bit value
                if (nDecel8) {

                    sd.dirBits &=  ~0x40; // Clear linear flag

                    sDReader.setBytesToRead1();
                    PT_WAIT_THREAD(sDReader);

                    if (limiting)
                        sd.timer = STD min (
                            (uint16_t)( ((uint32_t)*sDReader.readData * timerScale) >> 10 ),
                            (uint16_t)0xffff );
                    else
                        sd.timer = *sDReader.readData;

                    computeStepBits();

                    // PT_WAIT_WHILE(stepBuffer.enough());

                    PT_WAIT_WHILE(decStepsThisRun() == 0);
                    stepBuffer.pushRef(sd);

                    sd.dirBits &= ~0x80; // clear set-direction bit (after push)

                    // for (step16 = 1; step16 < nDecel8; step16++)
                    if (--nDecel8) do {

                        sDReader.setBytesToRead1();
                        PT_WAIT_THREAD(sDReader);

                        if (limiting)
                            sd.timer = STD min (
                                (uint16_t)( ((uint32_t)*sDReader.readData * timerScale) >> 10 ),
                                (uint16_t)0xffff );
                        else
                            sd.timer = *sDReader.readData;

                        computeStepBits();

                        // PT_WAIT_WHILE(stepBuffer.enough());

                        PT_WAIT_WHILE(decStepsThisRun() == 0);
                        stepBuffer.pushRef(sd);

                    } while (--nDecel8); 
                }

                // Timer value as 16bit value
                if (nDecel16) {

                    sd.dirBits &=  ~0x40; // Clear linear flag

                    sDReader.setBytesToRead2();
                    PT_WAIT_THREAD(sDReader);

                    if (limiting)
                        sd.timer = STD min (
                            (uint16_t)( ((uint32_t)FromBuf(uint16_t, sDReader.readData) * timerScale) >> 10 ),
                            (uint16_t)0xffff );
                    else
                        sd.timer = FromBuf(uint16_t, sDReader.readData);

                    computeStepBits();

                    // PT_WAIT_WHILE(stepBuffer.enough());

                    PT_WAIT_WHILE(decStepsThisRun() == 0);
                    stepBuffer.pushRef(sd);

                    sd.dirBits &= ~0x80; // clear set-direction bit (after push)

                    // for (step16 = 1; step16 < nDecel16; step16++)
                    if (--nDecel16) do {

                        sDReader.setBytesToRead2();
                        PT_WAIT_THREAD(sDReader);

                        if (limiting)
                            sd.timer = STD min (
                                (uint16_t)( ((uint32_t)FromBuf(uint16_t, sDReader.readData) * timerScale) >> 10 ),
                                (uint16_t)0xffff );
                        else
                            sd.timer = FromBuf(uint16_t, sDReader.readData);

                        computeStepBits();

                        // PT_WAIT_WHILE(stepBuffer.enough());

                        PT_WAIT_WHILE(decStepsThisRun() == 0);
                        stepBuffer.pushRef(sd);

                    } while (--nDecel16);
                }

                if (flags & 0x0400) {
                    // Endmove, speed is lower or equal jerk speed, so this is a good
                    // candidate for a printer stop...
                    if (stopRequested) {

                        // printf("softstopopping... %d bytes\n", stepBuffer.byteSize());
                        // Empty sdreader but let stepbuffer drain normally: 
                        sDReader.flush(); // resets swapdev also
                    }
                }

                PT_RESTART();

            HandleCmdG1Raw:

                PT_WAIT_WHILE( (stepsThisRun = ((uint8_t)255 - stepBuffer.size())) == 0 );

                // Read flag word and stepper direction bits
                sDReader.setBytesToRead2();
                PT_WAIT_THREAD(sDReader);
                flags = FromBuf(uint16_t, sDReader.readData);

                if (flags & 0x80)
                    // Change stepper direction(s)
                    sd.dirBits = flags & 0x9F;

                sd.dirBits &=  ~0x40; // Clear linear flag
                // if (flags & MeasureStartBitRaw) // Measurement move
                    // sd.dirBits |=  0x40; // Set measurement flag
                // else
                    // sd.dirBits &=  ~0x40; // Clear measurement flag

                // ???
                // cmdSync = true;

                //
                // Read len of pulses array, 2 bytes short uint
                //
                sDReader.setBytesToRead2();
                PT_WAIT_THREAD(sDReader);
                count = FromBuf(uint16_t, sDReader.readData);

// #if defined(USEExtrusionRateTable)
                //////////////////////////////////////////////////////
                limiting = false;

                // Check beginning of new base move
                if (flags & 0x20) {

                    sDReader.setBytesToRead4();
                    PT_WAIT_THREAD(sDReader);
                    eSpeedTimer.value = FromBuf(uint32_t, sDReader.readData);

                    sDReader.setBytesToRead1();
                    PT_WAIT_THREAD(sDReader);
                    eSpeedTimer.shift = *sDReader.readData;

                    // printf("eSpeedTimer: %d\n", eSpeedTimer);

                    // Lookup this e-speed in the extrusion rate table
                    int16_t curTempIndex = fromFWTemp( current_temperature[0] ) - extrusionLimitBaseTemp;

                    // printf("curTempIndex: %d\n", curTempIndex);

                    if (curTempIndex < 0) {

                        // printf("temp low, use first entry\n");
                        maxTempSpeed = tempExtrusionRateTable[0];
                    }
                    else if (curTempIndex >= NExtrusionLimit) {

                        // printf("temp high, use last entry\n");
                        maxTempSpeed = tempExtrusionRateTable[NExtrusionLimit-1];
                    }
                    else {

                        // printf("temp in range\n");
                        maxTempSpeed = tempExtrusionRateTable[curTempIndex];
                    }

                    timerScale = min( 
                            (maxTempSpeed * eSpeedTimer.value) >> eSpeedTimer.shift,
                            (uint32_t)(4*1024) );       // scale 1024

                    if (timerScale > 1024) {

                        if (filamentSensor.isLimiting()) {

                            // Speed is additionally limited by feeder grip/slip
                            timerScale = (timerScale * filamentSensor.getSlowDown()) >> 10; // scale pow(1024) -> 1024
                            printer.underGrip = min(printer.underGrip+1, 0xffff);

                            // printer.sendGenericInt32(timerScale);
                        }

                        #if ! defined(COLDEXTRUSION)
                        limiting = true;
                        printer.underTemp = min(printer.underTemp+1, 0xffff);
                        #endif
                    }
                    else {

                        // Speed is not limited by temperature
                        if (filamentSensor.isLimiting()) {

                            timerScale = filamentSensor.getSlowDown();       // scale 1024
                            limiting = true;
                            printer.underGrip = min(printer.underGrip+1, 0xffff);

                            // printer.sendGenericInt32(timerScale);
                        }
                        else if (printer.isLimiting()) {
                            timerScale = printer.getSlowDown();       // scale 1024
                            limiting = true;
                            // dont update statistic value underGrip if in debug/
                            // measurement mode.
                        }
                    }
                }
    
                // #if defined(HEAVYDEBUG)
                if (limiting) {
                    // if ((dbgcount++ & 0xf) == 0) {
                        // printer.sendGenericInt32(timerScale);
                    // }
                    massert(timerScale >= 512);
                }
                // #endif
                //////////////////////////////////////////////////////
// #endif // #if defined(USEExtrusionRateTable)

                sDReader.setBytesToRead2();
                PT_WAIT_THREAD(sDReader);
                lastTimer = FromBuf(uint16_t, sDReader.readData);

                if (limiting) 
                    sd.timer = STD min ( 
                        (uint16_t)( ((uint32_t)lastTimer * timerScale) >> 10 ),
                        (uint16_t)0xffff);
                else 
                    sd.timer = lastTimer;

                sDReader.setBytesToRead1();
                PT_WAIT_THREAD(sDReader);
                sd.stepBits = *sDReader.readData;

                // PT_WAIT_WHILE(stepBuffer.enough());

                PT_WAIT_WHILE(decStepsThisRun() == 0);
                stepBuffer.pushRef(sd);

                sd.dirBits &= ~0x80; // clear set-direction bit (after push)

                if (flags & RawByteFlag) {
                    //
                    // Read pulse array, first element is a 16bit timer value and 8bit stepper mask,
                    // then elements of 8bit timer delta and 8bit stepper mask
                    //
                    if (--count) do {

                        sDReader.setBytesToRead1();
                        PT_WAIT_THREAD(sDReader);
                        lastTimer += FromBuf(int8_t, sDReader.readData);

                        if (limiting) 
                            sd.timer = STD min ( 
                                (uint16_t)( ((uint32_t)lastTimer * timerScale) >> 10 ),
                                (uint16_t)0xffff);
                        else 
                            sd.timer = lastTimer;

                        sDReader.setBytesToRead1();
                        PT_WAIT_THREAD(sDReader);
                        sd.stepBits = *sDReader.readData;

                        // PT_WAIT_WHILE(stepBuffer.enough());

                        PT_WAIT_WHILE(decStepsThisRun() == 0);
                        stepBuffer.pushRef(sd);

                    } while (--count);
                }
                else {
                    //
                    // Read pulse array, elements of 16bit timer and 8bit stepper mask
                    //
                    if (--count) do {

                        sDReader.setBytesToRead2();
                        PT_WAIT_THREAD(sDReader);

                        if (limiting) 
                            sd.timer = STD min ( 
                                (uint16_t)( ((uint32_t)FromBuf(uint16_t, sDReader.readData) * timerScale) >> 10 ),
                                (uint16_t)0xffff);
                        else 
                            sd.timer = FromBuf(uint16_t, sDReader.readData);

                        sDReader.setBytesToRead1();
                        PT_WAIT_THREAD(sDReader);
                        sd.stepBits = *sDReader.readData;

                        // PT_WAIT_WHILE(stepBuffer.enough());
                        
                        PT_WAIT_WHILE(decStepsThisRun() == 0);
                        stepBuffer.pushRef(sd);

                    } while (--count);
                }

                if (flags & 0x0200) {
                    // Endmove, speed is lower or equal jerk speed, so this is a good
                    // candidate for a printer stop...
                    if (stopRequested) {

                        // printf("softstopopping... %d bytes\n", stepBuffer.byteSize());
                        // Empty sdreader but let stepbuffer drain normally: 
                        sDReader.flush(); // resets swapdev also
                    }
                }

                PT_RESTART();

            HandleCmdSyncFanSpeed:

                // Read fanspeed, bliptime
                sDReader.setBytesToRead2();
                PT_WAIT_THREAD(sDReader);

                printer.cmdFanSpeed(*sDReader.readData, *(sDReader.readData+1));

                PT_RESTART();

            HandleCmdSyncTargetTemp:

                sDReader.setBytesToRead3();
                PT_WAIT_THREAD(sDReader);

                printer.cmdSetTargetTemp(
                        *sDReader.readData, 
                        FromBuf(int16_t, sDReader.readData+1));

                PT_RESTART();

            HandleCmdDwellMS:

                //
                // Dwell is is done by executing a number of *NOP* moves that don't step any stepper
                // but are waiting for 25 mS.
                //
                // Read number of 25 mS nop segemnts as 16 bit unsigned int
                sDReader.setBytesToRead2();
                PT_WAIT_THREAD(sDReader);

                nDwell = FromBuf(uint16_t, sDReader.readData);

                sd.stepBits = 0;     // We don't step
                sd.timer    = 50000; // 25 mS for 2 mhz clock

                while (nDwell-- > 0) {

                    // PT_WAIT_WHILE(stepBuffer.enough());
                    PT_WAIT_WHILE(stepBuffer.full());
                    stepBuffer.pushRef(sd);
                }

                PT_RESTART();

            HandleCmdSuggestPwm:

                sDReader.setBytesToRead4();
                PT_WAIT_THREAD(sDReader);

                printer.cmdSetTargetTemp(
                        *sDReader.readData,
                        FromBuf(int16_t, sDReader.readData+1),
                        *(sDReader.readData+3));

                PT_RESTART();

            HandleCmdNop:

                PT_RESTART();

            PT_END(); // Not reached
        }

        // void sync() {
            // cmdSync = false;
        // }

        // bool synced() {
            // return cmdSync;
        // }

        // Flush/init swap, swapreader, fillbuffer task and stepbuffer
        void flush() {

            // step = deltaLead;
            // step16 = 0xFFFF;
            count = 1;
            step32 = 1;
            // cmdSync = false;
            stopRequested = false;
            Restart();

            sDReader.flush(); // resets swapdev also
            stepBuffer.flush();
        }

        // Request a printer soft stop
        void requestSoftStop() { stopRequested = true; }

        //
        // Compute stepper bits, bresenham
        //
        FWINLINE void computeStepBits() {

            // sd.stepBits = 1 << leadAxis;
            sd.stepBits = leadAxisBit;

            #if 0
            for (uint8_t i=0; i<5; i++) {

                if (i == leadAxis)
                    continue;

                if (d_axis[i] < 0) {
                    //  d_axis[a] = d + 2 * abs_displacement_vector_steps[a]
                    d_axis[i] += d1_axis[i];
                }
                else {
                    //  d_axis[a] = d + 2 * (abs_displacement_vector_steps[a] - deltaLead)
                    d_axis[i] += d2_axis[i];
                    sd.stepBits |= 1 << i;
                }
            }
            #endif
            //
            // Unrolled loop
            //
            if (leadAxis != 0) {
                if (d_axis[0] < 0) {
                    //  d_axis[a] = d + 2 * abs_displacement_vector_steps[a]
                    d_axis[0] += d1_axis[0];
                }
                else {
                    //  d_axis[a] = d + 2 * (abs_displacement_vector_steps[a] - deltaLead)
                    d_axis[0] += d2_axis[0];
                    sd.stepBits |= 0x1;
                }
            }
            if (leadAxis != 1) {
                if (d_axis[1] < 0) {
                    //  d_axis[a] = d + 2 * abs_displacement_vector_steps[a]
                    d_axis[1] += d1_axis[1];
                }
                else {
                    //  d_axis[a] = d + 2 * (abs_displacement_vector_steps[a] - deltaLead)
                    d_axis[1] += d2_axis[1];
                    sd.stepBits |= 0x2;
                }
            }
            if (leadAxis != 2) {
                if (d_axis[2] < 0) {
                    //  d_axis[a] = d + 2 * abs_displacement_vector_steps[a]
                    d_axis[2] += d1_axis[2];
                }
                else {
                    //  d_axis[a] = d + 2 * (abs_displacement_vector_steps[a] - deltaLead)
                    d_axis[2] += d2_axis[2];
                    sd.stepBits |= 0x4;
                }
            }
            if (leadAxis != 3) {
                if (d_axis[3] < 0) {
                    //  d_axis[a] = d + 2 * abs_displacement_vector_steps[a]
                    d_axis[3] += d1_axis[3];
                }
                else {
                    //  d_axis[a] = d + 2 * (abs_displacement_vector_steps[a] - deltaLead)
                    d_axis[3] += d2_axis[3];
                    sd.stepBits |= 0x8;
                }
            }
            if (leadAxis != 4) {
                if (d_axis[4] < 0) {
                    //  d_axis[a] = d + 2 * abs_displacement_vector_steps[a]
                    d_axis[4] += d1_axis[4];
                }
                else {
                    //  d_axis[a] = d + 2 * (abs_displacement_vector_steps[a] - deltaLead)
                    d_axis[4] += d2_axis[4];
                    sd.stepBits |= 0x10;
                }
            }
        }
};

FillBufferTask fillBufferTask;

void Timer::run(uint32_t m) {

    if (fanEndTime && (m >= fanEndTime)) {

        FAN_PIN :: write(fanSpeed);
        fanEndTime = 0;
    }

#if defined(__arm__)
    if (bootBootloaderRequest) {

        // Wait until we sent our acknowledge to keep
        // usb-serial communication clean.
        if (txBuffer.empty()) {
            JumpToBootloader();
            // notreached
        }
    }
#endif

    if (resetRequest) {

        // Wait until we sent our acknowledge to keep
        // usb-serial communication clean.
        if (txBuffer.empty()) {
            HAL_SYSTEM_RESET();
            // notreached
        }
    }

    if ((baudRate >= 0) && (m >= baudRateTime)) {
        
        if (txBuffer.size() > 0)
            return;

        rxBuffer.setBaudrate(baudRate);

        baudRate = -1;
    }
}

Timer timer;


Printer::Printer() {

    printerState = StateIdle;
    moveType = MoveTypeNone;
    homed = false;

    for (int heater=0; heater<N_HEATERS; heater++)
        increaseTemp[heater] = 0;

    powerOffTime = 0;

    bufferLow = 0;

    // Init initial temp-speed table with no real limitations.
    // The real values are downloaded by the host
    // software before print (CmdSetTempTable).
    for (uint8_t i=0; i<NExtrusionLimit; i++) {
        tempExtrusionRateTable[i] = (uint16_t)0x50;
    }
};

void Printer::printerInit() {

    // Todo: handle already running state
    massert(printerState <= StateInit);

    nGenericMessage = 0;

    // Init buffers
    fillBufferTask.flush();

    printerState = StateInit;

#if defined(LED_PIN)
    LED_PIN :: write(255);
#endif
#if defined(MB_FAN_PIN)
    MB_FAN_PIN :: activate();
#endif

    slowdown = 1024;
}

void Printer::runErase() {

    //
    // Erase sdcard to speed up block writes.
    //
    if (printerState == StateErasing) {

#if defined(AVR)
        // Erase in 50mb chunks
        uint32_t blocksThisRun = min((uint32_t)2048*50, blocksToErase);

        massert(swapDev.erase(eraseStartBlock, (eraseStartBlock+blocksThisRun) - 1));

        eraseStartBlock += blocksThisRun;
        blocksToErase -= blocksThisRun;

        if (blocksToErase == 0)
            printerState = StateInit; // Erase done
#else
        printerState = StateInit; // Nop Erase done
#endif
    }
}

void Printer::sendGenericMessage(const char *s, uint8_t l) {

    if (nGenericMessage++ > 50)
        return;

    txBuffer.sendResponseStart(RespUnsolicitedMsg);
    txBuffer.sendResponseUint8(GenericMessage);
    txBuffer.sendResponseString(s, l);
    txBuffer.sendResponseEnd();
}

void Printer::sendGenericInt32(int32_t v) {

    txBuffer.sendResponseStart(RespUnsolicitedMsg);
    txBuffer.sendResponseUint8(GenericInt32);
    txBuffer.sendResponseInt32(v);
    txBuffer.sendResponseEnd();
}

void Printer::runHotEndFan() {

#if defined(HOTEND_FAN_PIN)
    if ((hotEndFanOn == false) && (current_temperature[0] >= toFWTemp((int16_t)40))) {

        // Hotend fan on
        HOTEND_FAN_PIN :: activate();
        hotEndFanOn = true;
    }
    else if ((hotEndFanOn == true) && (current_temperature[0] <= toFWTemp((int16_t)35))) {

        // Hotend fan off
        HOTEND_FAN_PIN :: deActivate();
        hotEndFanOn = false;
    }
#endif

}

void Printer::underrunError() {

    printer.bufferLow = min((uint32_t)printer.bufferLow+1, (uint32_t)0xffff);

    // txBuffer.sendResponseStart(RespUnsolicitedMsg);
    // txBuffer.sendResponseUint8(BufDebug);
    // txBuffer.sendResponseUInt32(swapDev.available());
    // txBuffer.sendResponseUInt32(sDReader.available());
    // txBuffer.sendResponseEnd();

    // kill();
}

void Printer::cmdMove(MoveType mt) {

    massert(mt != MoveTypeNone);
    massert(printerState == StateInit);

    printerState = StateStart;
    moveType = mt;

    minBuffer = 255;

    underTemp = underGrip = 0;

    uint8_t stepperMask = 0;

#if ! defined(COLDMovement)
    stepperMask |= st_get_move_bit_mask<XAxisSelector>();
    stepperMask |= st_get_move_bit_mask<YAxisSelector>();
    stepperMask |= st_get_move_bit_mask<ZAxisSelector>();
#endif

#if ! defined(COLDEXTRUSION)
    stepperMask |= st_get_move_bit_mask<EAxisSelector>();
#endif

    st_enableSteppers(stepperMask);

    bufferLow = 0;

#if defined(HASFILAMENTSENSOR) || defined(RUNFILAMENTSENSOR)
    filamentSensor.init();
#endif

    if (mt == MoveTypeHoming) {
        stepBuffer.homingMode();
    }
    else {
        HAL_SET_STEPPER_TIMER(2000); // 1kHz.
        ENABLE_STEPPER_DRIVER_INTERRUPT();
    }
}

void Printer::setPos(int32_t x, int32_t y, int32_t z) {
         
    homed = true;

    current_pos_steps[X_AXIS] = x;
    current_pos_steps[Y_AXIS] = y;
    current_pos_steps[Z_AXIS] = z;
}

void Printer::cmdSetTargetTemp(uint8_t heater, int16_t temp, uint8_t pwmOverride) {

    if (temp > 50)
        tempControl.setTemp(heater, temp + increaseTemp[heater], pwmOverride);
    else
        tempControl.setTemp(heater, temp, pwmOverride);
}

void Printer::cmdSetIncTemp(uint8_t heater, int16_t incTemp) {

    massert((heater >= 0) && (heater < N_HEATERS));
    massert(abs(incTemp) <= toFWTemp((int16_t)15));

    increaseTemp[heater] = incTemp;
}

void Printer::cmdGetFreeMem() {

    txBuffer.sendResponseStart(CmdGetFreeMem);
    txBuffer.sendResponseUInt32((uint32_t)freeRam());
    txBuffer.sendResponseEnd();
}

void Printer::cmdSetPIDValues(

    ScaledUInt32 &kp,
    ScaledUInt32 &ki, int32_t   maxEsum,
    ScaledUInt32 &kd,
    ScaledUInt32 &kpC,
    ScaledUInt32 &kiC, int32_t  maxEsumC,
    ScaledUInt32 &kdC,
    ScaledUInt32 &kiSwitchToHeating,
    ScaledUInt32 &kiSwitchToCooling,
    uint16_t tu) {

    tempControl.setPIDValues(
        kp,
        ki, maxEsum,
        kd,
        kpC,
        kiC, maxEsumC,
        kdC,
        kiSwitchToHeating, kiSwitchToCooling);
    Tu = tu;
}

void Printer::cmdSetStepsPerMM(uint16_t spmmX, uint16_t spmmY, uint16_t spmmZ) {
    stepsPerMMX = spmmX;
    stepsPerMMY = spmmY;
    stepsPerMMZ = spmmZ;
}

void Printer::cmdSetHostSettings(HostSettings &hs) {

    hostSettings = hs;
}

void Printer::cmdGetCardSize() {

    txBuffer.sendResponseStart(CmdGetCardSize);
    txBuffer.sendResponseInt32((int32_t)swapDev.cardSize() - 1);
    txBuffer.sendResponseEnd();
}

void Printer::cmdErase(uint32_t nBlocks) {

    massert(printerState == StateInit);
    eraseStartBlock = 1;
    blocksToErase = nBlocks;
    printerState = StateErasing;
}

void Printer::cmdFanSpeed(uint8_t speed, uint8_t blipTime) {

    // If no blip is used, start fan directly, else
    // start fan at 100% and start a timer to lower
    // pwm value after the bliptime.
    if (blipTime) {

        FAN_PIN :: write(255);
        timer.startFanTimer(speed, blipTime);
        return;
    }

    timer.endFanTimer();
#if defined(MIN_FAN_PWM)
    FAN_PIN :: write(max((uint8_t)MIN_FAN_PWM, speed));
#else
    FAN_PIN :: write(speed);
#endif
}

/*
 * Hard stop, without deceleration
 */
void Printer::cmdStopMove() {

    cmdSetTargetTemp(0, 0);
    cmdSetTargetTemp(1, 0);
    cmdSetTargetTemp(2, 0);

    DISABLE_STEPPER_DRIVER_INTERRUPT();
    DISABLE_STEPPER1_DRIVER_INTERRUPT();

    printerState = StateInit;
    moveType = MoveTypeNone;

    // Flush remaining steps
    fillBufferTask.flush();

    cmdFanSpeed(0, 0);
}

void Printer::cmdGetTargetTemps() {

    txBuffer.sendResponseStart(CmdGetTargetTemps);

    txBuffer.sendResponseInt16(target_temperature_bed);
    txBuffer.sendResponseInt16(target_temperature[0]);
    txBuffer.sendResponseUInt16(0 /* target_temperature[1] */);
    txBuffer.sendResponseEnd();
}

void Printer::cmdGetCurrentTemps() {

    txBuffer.sendResponseStart(CmdGetCurrentTemps);

    txBuffer.sendResponseInt16(current_temperature_bed);
    txBuffer.sendResponseInt16(current_temperature[0]);
    txBuffer.sendResponseInt16(0 /* current_temperature[1] */);
    txBuffer.sendResponseEnd();
}

// Note: we don't check if mass-storage is busy.
// Note: we don't merge the config here, we just overwrite it.
// This is no problem as long the config is just the printer name. 
void Printer::cmdSetPrinterName(char *name, uint8_t len) {

    union MSConfigBlock configSector;

    memset(configSector.config.printerName, 0, sizeof(configSector.config.printerName));
    strncpy(configSector.config.printerName, name, STD min(len, (uint8_t)sizeof(configSector.config.printerName)));

    // No error checking
    swapDev.writeConfig(configSector);

    txBuffer.sendResponseStart(CmdSetPrinterName);
    txBuffer.sendResponseUint8(RespOK);
    txBuffer.sendResponseEnd();
}

// Note: we don't check if mass-storage is busy.
void Printer::cmdGetPrinterName() {

    union MSConfigBlock configSector;

    // No error checking
    swapDev.readConfig(configSector);

    txBuffer.sendResponseStart(CmdGetPrinterName);
    txBuffer.sendResponseUint8(RespOK);

    txBuffer.sendResponseString(
            configSector.config.printerName,
            strnlen(configSector.config.printerName, sizeof(configSector.config.printerName)-1));

    txBuffer.sendResponseEnd();
}

void Printer::cmdGetVersion() {

    txBuffer.sendResponseStart(CmdGetVersion);
    txBuffer.sendResponseUint8(RespOK);

    txBuffer.sendResponseString( gitversion, strlen(gitversion) );

    txBuffer.sendResponseEnd();
}

void Printer::checkPrintFinished() {

    //
    // Print is finished if:
    // * read file pos is at the end of file
    // * buffers are empty
    //
    if (printerState == StateStart) {

        if ((moveType == MoveTypeHoming) && (! STEPPER1_DRIVER_INTERRUPT_ENABLED())) {

            // Flush remaining steps
            fillBufferTask.flush();
        }

        if (! swapDev.busy()) {

            // if (swapDev.getWritePos()) {
                // // Save last partial block
                // swapDev.startWriteBlock();
                // return;
            // }

            if ((! swapDev.available()) &&
                (! sDReader.available()) &&
                stepBuffer.empty() ) {

                // printf("finish ok...\n");

                DISABLE_STEPPER_DRIVER_INTERRUPT();
                DISABLE_STEPPER1_DRIVER_INTERRUPT();

                swapDev.reset();

                printerState = StateInit;
                moveType = MoveTypeNone;

                // Reset swap/buffers
                fillBufferTask.flush();
            }
        }
    }
}

void Printer::disableSteppers() {

    st_disableSteppers();

    homed = false;

#if defined(LED_PIN)
    LED_PIN :: write(255 * 0.5);
#endif

    printerState = StateIdle;
}

void Printer::cmdDisableSteppers() {

    disableSteppers();
}

#if 0
// Currently not used:
void Printer::cmdDisableStepperIsr() {

    DISABLE_STEPPER_DRIVER_INTERRUPT();
    DISABLE_STEPPER1_DRIVER_INTERRUPT();
}
#endif

void Printer::cmdGetHomed() {

    txBuffer.sendResponseStart(CmdGetHomed);
    txBuffer.sendResponseUint8((uint8_t)homed);
    txBuffer.sendResponseEnd();
}

void Printer::cmdGetEndstops() {

    txBuffer.sendResponseStart(CmdGetEndstops);

    txBuffer.sendResponseUint8(X_STOP_PIN :: active());
    txBuffer.sendResponseInt32(current_pos_steps[X_AXIS]);

    txBuffer.sendResponseUint8(Y_STOP_PIN :: active());
    txBuffer.sendResponseInt32(current_pos_steps[Y_AXIS]);

    txBuffer.sendResponseUint8(Z_STOP_PIN :: active());
    txBuffer.sendResponseInt32(current_pos_steps[Z_AXIS]);

#if defined(DualZStepper)
    txBuffer.sendResponseUint8(Z1_STOP_PIN :: active());
    txBuffer.sendResponseInt32(current_pos_steps[Z_AXIS]);
#else
    txBuffer.sendResponseUint8(0);
    txBuffer.sendResponseInt32(0);
#endif

    txBuffer.sendResponseEnd();
}

void Printer::cmdGetPos() {

    txBuffer.sendResponseStart(CmdGetPos);
    txBuffer.sendResponseInt32(current_pos_steps[X_AXIS]);
    txBuffer.sendResponseInt32(current_pos_steps[Y_AXIS]);
    txBuffer.sendResponseInt32(current_pos_steps[Z_AXIS]);
    txBuffer.sendResponseInt32(current_pos_steps[E_AXIS]);
    txBuffer.sendResponseEnd();
}

#if defined(DEBUGPROCSTAT)
void Printer::cmdGetTaskStatus() {

    txBuffer.sendResponseStart(CmdGetTaskStatus);
    for (uint8_t i=0; i<(sizeof(taskTiming) / sizeof(struct TaskTiming)); i++) {
        txBuffer.sendResponseUInt32(taskTiming[i].ncalls);
        txBuffer.sendResponseUInt32(taskTiming[i].sumcall);
        txBuffer.sendResponseUInt32(taskTiming[i].longest);
    }
    txBuffer.sendResponseEnd();
} 
#endif

#if defined(DEBUGREADWRITE)
void Printer::cmdGetIOStats() {

    txBuffer.sendResponseStart(CmdGetIOStats);
    for (uint8_t i=0; i<(sizeof(swapDev.ioStats) / sizeof(struct TaskTiming)); i++) {
        txBuffer.sendResponseUInt32(swapDev.ioStats[i].ncalls);
        txBuffer.sendResponseUInt32(swapDev.ioStats[i].sumcall);
        txBuffer.sendResponseUInt32(swapDev.ioStats[i].longest);
    }
    txBuffer.sendResponseEnd();
}
#endif

void Printer::cmdSetBaudRate(uint32_t br) {

    timer.baudRateTimer(br);
}

void Printer::cmdGetStatus() {

    txBuffer.sendResponseStart(CmdGetStatus);

    txBuffer.sendResponseUint8(printerState);
    txBuffer.sendResponseInt16(current_temperature_bed);
    txBuffer.sendResponseInt16(current_temperature[0]);
    txBuffer.sendResponseUInt32(swapDev.available());
    txBuffer.sendResponseUInt32(swapDev.getSize());
    txBuffer.sendResponseUInt16(sDReader.available());
    txBuffer.sendResponseUInt32(stepBuffer.size());
    txBuffer.sendResponseInt16(bufferLow);
    txBuffer.sendResponseUInt16(target_temperature_bed);
    txBuffer.sendResponseUInt16(target_temperature[0]);
    txBuffer.sendResponseUint8(tempControl.getPwmOutput());

    // Flowrate sensor
#if defined(HASFILAMENTSENSOR) || defined(RUNFILAMENTSENSOR)
    txBuffer.sendResponseInt16(filamentSensor.getSlip32());
    if (filamentSensor.isLimiting())
        txBuffer.sendResponseUInt16(filamentSensor.getSlowDown());
    else
        txBuffer.sendResponseUInt16(1024);
#else
    // Ramps or other test boards without filsensor
    txBuffer.sendResponseInt16(32);
    txBuffer.sendResponseUInt16(1024);
#endif

    txBuffer.sendResponseInt32(current_pos_steps[E_AXIS]);
    txBuffer.sendResponseUint8(minBuffer);
    txBuffer.sendResponseUInt16(underTemp);
    txBuffer.sendResponseUInt16(underGrip);

    txBuffer.sendResponseEnd();
}

#if defined(HASFILAMENTSENSOR) || defined(RUNFILAMENTSENSOR)
void Printer::cmdGetFilSensor() {

    txBuffer.sendResponseStart(CmdGetFilSensor);
    txBuffer.sendResponseInt32(filamentSensor.getSensorCount());
    txBuffer.sendResponseEnd();
}
#endif

void Printer::cmdSetFilSensorConfig(ScaledUInt16 & cal, uint16_t fsrMinSteps) {

#if defined(HASFILAMENTSENSOR) || defined(RUNFILAMENTSENSOR)
    filamentSensor.setFilSensorConfig(cal, fsrMinSteps);
#endif
}

void Printer::cmdSetFilSensorCal(ScaledUInt16 & cal) {

#if defined(HASFILAMENTSENSOR)
    filamentSensor.setCalibration(cal);
#endif
}

// #if defined(USEExtrusionRateTable)
void Printer::cmdSetTempTable() {

    extrusionLimitBaseTemp = rxBuffer.readInt16NoCheckCobs();

    uint8_t len = rxBuffer.readNoCheckCobs();
    if (len != NExtrusionLimit) {

        txBuffer.sendSimpleResponse(CmdSetTempTable, RespInvalidArgument);
        return;
    }

    for (uint8_t i=0; i<NExtrusionLimit; i++) {
        tempExtrusionRateTable[i] = rxBuffer.readUInt16NoCheckCobs();
    }

    txBuffer.sendSimpleResponse(CmdSetTempTable, RespOK);
}
// #endif

void Printer::cmdReadGpio(uint8_t pinNumber) {

    // Set pin to input
    HAL_SET_INPUT_PU(pinNumber);

    // Read pin
    uint32_t val = HAL_READ(pinNumber);

    txBuffer.sendResponseStart(CmdReadGpio);
    txBuffer.sendResponseUInt32(val);
    txBuffer.sendResponseEnd();
}

void Printer::cmdReadAnalogGpio(uint8_t pinNumber) {

    // Set pin to analog input
    HAL_SET_INPUT_ANALOG(pinNumber);

    // Read pin
    uint32_t val = HAL_READ_ANALOG(pinNumber);

    txBuffer.sendResponseStart(CmdReadAnalogGpio);
    txBuffer.sendResponseUInt32(val);
    txBuffer.sendResponseEnd();
}

void Printer::cmdSetGpio(uint8_t pinNumber, uint8_t value) {

    // Set pin to input
    HAL_SET_OUTPUT(pinNumber);

    // Set pin
    HAL_WRITE(pinNumber, value);
}

#if defined(POWER_BUTTON)
void Printer::checkPowerOff(uint32_t m) {

    //
    // Check for power-off request
    //
    if (POWER_BUTTON :: active()) {
        if (! powerOffTime) {
            // Power off if power button is held for 3 seconds
            powerOffTime = m + 2000;
        }
    }
    else {
        if (powerOffTime) {
            if (m > powerOffTime) {
                // WRITE(POWER_SUPPLY_RELAY, LOW);
                POWER_SUPPLY_RELAY :: deActivate();
            }
            else {
                powerOffTime = 0;
            }
        }
    }
}
#endif

bool Printer::stepsAvailable() {

    return sDReader.available() > 512;
}

void Printer::cmdDumpMassStorage(uint32_t block) {

    // uint8_t buffer[512];

    massert( ! swapDev.busy() );
    massert(0); // swapDev.startReadBlock(buffer, block>>1);
    while (swapDev.Run()) { }

    txBuffer.sendResponseStart(CmdDumpMassStorage);
    // txBuffer.sendResponseBlob(buffer+(256*(block & 1)), 256);
    txBuffer.sendResponseEnd();
}

Printer printer;

class UsbCommand : public Protothread {
    public:

        // Result of waitForSerial()
        typedef enum {
            NothingAvailable,       // 
            CharsAvailable,       // 
            SerTimeout
            } SerAvailableState;

        // Timestamp of start character of a usbserial command, to
        // detect timeout's.
        uint32_t startTS;

        // Command serial number [1..255]
        uint8_t serialNumber;

        uint8_t commandByte;

        // Computed checksum
        uint16_t checksum;

        // Number of characters we have to read
        uint16_t payloadLength;

        //
        // Cobs decoder
        //
        uint8_t cobsCodeLen;
        uint8_t counter;
        uint8_t chunk;

        UsbCommand() {
            serialNumber = 1;
        }

        void reset() {

            // Drain usbserial buffers for 50 ms
            rxBuffer.ringBufferInit();
        }

        void crcError() {

            txBuffer.sendSimpleResponse(RespRXCRCError, serialNumber);
            reset();
        }

        void serialNumberError() {

            txBuffer.sendSimpleResponse(RespSerNumberError, serialNumber);
            reset();
        }

        //
        // Check if serial chars are available.
        //
        FWINLINE SerAvailableState waitForSerial(uint8_t nChars) {

            //
            // If a serial char gets lost, we have a deadlock situation: Firmware waits
            // for more characters to arrive and host application waits for
            // the acknowledge of the last sent command.
            //
            // To prevent this we implement a timeout here.
            //

            if (rxBuffer.size() >= nChars) {

                return CharsAvailable;
            }

            if ((millis() - startTS) > 250) {

                txBuffer.sendSimpleResponse(RespRXTimeoutError, serialNumber);
                reset();
                return SerTimeout;
            }

            return NothingAvailable;
        }


        bool Run() {

            static uint8_t c;
            uint8_t flags, cs1, cs2;
            SerAvailableState av;

            PT_BEGIN();

            // Read startbyte
            PT_WAIT_UNTIL( rxBuffer.size() );
            
            if (rxBuffer.pop() != SOH) {
                reset();
                PT_RESTART();
            }
            
            startTS = millis();

            checksum = 0xffff;

            // Read packet number and command
            PT_WAIT_WHILE( (av = waitForSerial(2)) == NothingAvailable );
            if (av == SerTimeout)
                PT_RESTART();

            // Packet serial number
            c = rxBuffer.pop();
            if (c == 0) { // Check for garbled input
                reset();
                PT_RESTART();
            }
            checksum = _crc_ccitt_update(checksum, c);

            // Read command byte
            commandByte = rxBuffer.pop();
            if (commandByte == 0) { // Check for garbled input
                reset();
                PT_RESTART();
            }

            checksum = _crc_ccitt_update(checksum, commandByte);

            if (commandByte < 128) { 

                //
                // Buffered command
                //
                if (c != serialNumber) {

                    serialNumberError();
                    PT_RESTART();   // does a return
                }

                payloadLength = 512;

                while (payloadLength) {

                    PT_WAIT_WHILE( (av = waitForSerial(1)) == NothingAvailable );
                    if (av == SerTimeout) {
                        swapDev.discardWriteBlock();
                        PT_RESTART();
                    }

                    cobsCodeLen = rxBuffer.pop();

                    checksum = _crc_ccitt_update(checksum, cobsCodeLen);

                    counter = min((uint16_t)(cobsCodeLen-1), payloadLength);
                    payloadLength -= counter;

                    while (counter) {

                        // Read in x byte chunks
                        chunk = min(counter, (uint8_t)16);

                        PT_WAIT_WHILE( (av = waitForSerial(chunk)) == NothingAvailable );
                        if (av == SerTimeout) {
                            swapDev.discardWriteBlock();
                            PT_RESTART();
                        }

                        counter -= chunk;

                        while (chunk) {

                            c = rxBuffer.pop();

                            swapDev.addByte(c);
                            checksum = _crc_ccitt_update(checksum, c);

                            chunk--;
                        }
                    }

                    if (payloadLength && (cobsCodeLen != 0xff)) {

                        swapDev.addByte(0);
                        payloadLength--;
                    }
                }

                PT_WAIT_WHILE( (av = waitForSerial(3)) == NothingAvailable );
                if (av == SerTimeout) {
                    swapDev.discardWriteBlock();
                    PT_RESTART();
                }

                flags = rxBuffer.pop();

                cs1 = rxBuffer.pop();

                cs2 = rxBuffer.pop();

                if (! checkCrc(flags, cs1, cs2, checksum)) {
                    swapDev.discardWriteBlock();
                    PT_RESTART();   // does a return
                }

                #if defined(HEAVYDEBUGRX)
                massert(rxBuffer.size() == 0);
                #endif

                // Write sector
                PT_WAIT_WHILE( swapDev.busy() );
                swapDev.startWriteBlock();

                // Successfully received command, increment command counter
                serialNumber++;
                if (serialNumber==0)
                    serialNumber = 1;

                PT_WAIT_WHILE( swapDev.busyWriting() );
                txBuffer.sendACK();
            }
            else {

                // 
                // Direct command
                // 

                // Read payload length 1 byte
                PT_WAIT_WHILE( (av = waitForSerial(1)) == NothingAvailable );
                payloadLength = rxBuffer.pop();
                checksum = _crc_ccitt_update(checksum, payloadLength);
                payloadLength--;

                // Wait for payload, checksum flags and two checksum bytes
                PT_WAIT_WHILE( (av = waitForSerial(payloadLength+3)) == NothingAvailable );
                if (av == SerTimeout)
                    PT_RESTART();

                rxBuffer.peekChecksum(&checksum, payloadLength);

                flags = rxBuffer.peekN(payloadLength);
                cs1 = rxBuffer.peekN(payloadLength+1);
                cs2 = rxBuffer.peekN(payloadLength+2);

                if (! checkCrc(flags, cs1, cs2, checksum))
                    PT_RESTART();   // does a return

                // Handle ResetLineNr command, set command counter
                if (commandByte == CmdResetLineNr) {
                    serialNumber = 1;
                }
                else {
                
                    if (c != serialNumber) {
                        serialNumberError();
                        PT_RESTART();   // does a return
                    }

                    // Successfully received command, increment command counter
                    serialNumber++;
                    if (serialNumber==0)
                        serialNumber = 1;
                }

                // Tell RxBuffer that it's pointing to the beginning of a COBS block
                rxBuffer.cobsInit(payloadLength);

                #if defined(HEAVYDEBUGRX)
                uint8_t bytesLeft = 3;
                #endif

                // LCDMSGXY(0, 0,"command:");
                // LCDMSG(commandByte);

                // Handle direct command
                switch (commandByte) {
                    //
                    // Simple ack commands, just one byte, no payload
                    //
                    case CmdResetLineNr:
                        txBuffer.sendACK();
                        break;
                    case CmdDisableSteppers:
                        printer.cmdDisableSteppers();
                        txBuffer.sendACK();
                        break;
                    case CmdPrinterInit:
                        printer.printerInit();
                        txBuffer.sendACK();
                        break;
                    case CmdMove: // move
                        printer.cmdMove((Printer::MoveType)rxBuffer.readNoCheckCobs());
                        txBuffer.sendACK();
                        break;
                    case CmdSetPos:
                        {
                            int32_t x = rxBuffer.readInt32NoCheckCobs();
                            int32_t y = rxBuffer.readInt32NoCheckCobs();
                            int32_t z = rxBuffer.readInt32NoCheckCobs();

                            // consume two additional ints
                            rxBuffer.readInt32NoCheckCobs();
                            rxBuffer.readInt32NoCheckCobs();

                            printer.setPos(x, y, z);
                            txBuffer.sendACK();
                        }
                        break;
                    case CmdSetTargetTemp:
                        {
                            uint8_t heater = rxBuffer.readNoCheckCobs();
                            uint16_t temp = rxBuffer.readUInt16NoCheckCobs();
                            printer.cmdSetTargetTemp(heater, temp);
                            txBuffer.sendACK();
                        }
                        break;
                    case CmdSetTempPWM:
                        {
                            uint8_t heater = rxBuffer.readNoCheckCobs();
                            uint8_t pwm = rxBuffer.readNoCheckCobs();
                            tempControl.setTempPWM(heater, pwm);
                            txBuffer.sendACK();
                        }
                        break;
                    case CmdStopMove:
                        printer.cmdStopMove();
                        txBuffer.sendACK();
                        break;
                    case CmdSoftStop:
                        fillBufferTask.requestSoftStop();
                        txBuffer.sendACK();
                        break;
                    case CmdGetCardSize:
                        printer.cmdGetCardSize();
                        break;
                    case CmdErase:
                        printer.cmdErase(rxBuffer.readUInt32NoCheckCobs());
                        txBuffer.sendACK();
                        break;
                    case CmdFanSpeed:
                        printer.cmdFanSpeed(rxBuffer.readNoCheckCobs(), 0);
                        txBuffer.sendACK();
                        break;

#if defined(HASFILAMENTSENSOR)
                    case CmdEnableFRLimit:
                        filamentSensor.enableFeedrateLimiter(rxBuffer.readNoCheckCobs());
                        txBuffer.sendACK();
                        break;
#else
                    case CmdEnableFRLimit:
                        {
                            rxBuffer.readNoCheckCobs();
                            filamentSensor.enableFeedrateLimiter(0);
                            txBuffer.sendACK();
                        }
                        break;
#endif

                    case CmdSetContTimer:
                        stepBuffer.setContinuosTimer(rxBuffer.readUInt16NoCheckCobs());
                        txBuffer.sendACK();
                        break;
                    case CmdContinuous: {
                        uint8_t stepperMask = rxBuffer.readNoCheckCobs();
                        uint16_t timerValue = rxBuffer.readUInt16NoCheckCobs();
                        stepBuffer.continuosMode(stepperMask, timerValue);
                        txBuffer.sendACK();
                        }
                        break;
                    case CmdSetFilSensorConfig: {
                        // float value = rxBuffer.readFloatNoCheckCobs();
                        ScaledUInt16 fsc;
                        fsc.value = rxBuffer.readUInt16NoCheckCobs();
                        fsc.shift = rxBuffer.readNoCheckCobs();
                        uint16_t fsrMinSteps = rxBuffer.readUInt16NoCheckCobs();
                        printer.cmdSetFilSensorConfig(fsc, fsrMinSteps);
                        txBuffer.sendACK();
                        }
                        break;
                    case CmdSetFilSensorCal: {
                        ScaledUInt16 fsc;
                        fsc.value = rxBuffer.readUInt16NoCheckCobs();
                        fsc.shift = rxBuffer.readNoCheckCobs();
                        printer.cmdSetFilSensorCal(fsc);
                        txBuffer.sendACK();
                        }
                        break;
#if defined(__arm__)
                    case CmdBootBootloader:
                        timer.startBootloaderTimer();
                        txBuffer.sendACK();
                        break;
#endif
                    case CmdReadGpio: {
                        uint8_t pinNumber = rxBuffer.readNoCheckCobs();
                        printer.cmdReadGpio(pinNumber);
                        }
                        break;
                    case CmdReadAnalogGpio: {
                        uint8_t pinNumber = rxBuffer.readNoCheckCobs();
                        printer.cmdReadAnalogGpio(pinNumber);
                        }
                        break;
                    case CmdSetGpio: {
                        uint8_t pinNumber = rxBuffer.readNoCheckCobs();
                        uint8_t value = rxBuffer.readNoCheckCobs();
                        printer.cmdSetGpio(pinNumber, value);
                        txBuffer.sendACK();
                        }
                        break;

                    //
                    // Commands with response payload
                    //
#if 0
                    case CmdGetDirBits:
                        printer.cmdGetDirBits();
                        break;
#endif
                    case CmdGetStatus:
                        printer.cmdGetStatus();
                        break;
#if defined(DEBUGPROCSTAT)
                    case CmdGetTaskStatus:
                        printer.cmdGetTaskStatus();
                        break;
#endif
#if defined(DEBUGREADWRITE)
                    case CmdGetIOStats:
                        printer.cmdGetIOStats();
                        break;
#endif
                    case CmdSetSlowDown: {
                        uint32_t scale = rxBuffer.readUInt32NoCheckCobs();
                        printer.cmdSetSlowDown(scale);
                        txBuffer.sendACK();
                        }
                        break;

                    case CmdSetBaudRate: {
                        uint32_t br = rxBuffer.readUInt32NoCheckCobs();
                        printer.cmdSetBaudRate(br);
                        txBuffer.sendACK();
                        }
                        break;

                    case CmdSetPrinterName: {
                        uint8_t len = rxBuffer.readNoCheckCobs();
                        char name[64];
                        for (c=0; c<64 && c<len; c++) {
                            name[c] = rxBuffer.readNoCheckCobs();
                        }
                        printer.cmdSetPrinterName(name, len);
                        }
                        break;
                    case CmdGetPrinterName:
                        printer.cmdGetPrinterName();
                        break;
                    case CmdGetHomed:
                        printer.cmdGetHomed();
                        break;
                    case CmdGetEndstops:
                        printer.cmdGetEndstops();
                        break;
                    case CmdGetPos:
                        printer.cmdGetPos();
                        break;
                    case CmdGetTargetTemps:
                        printer.cmdGetTargetTemps();
                        break;
                    case CmdGetCurrentTemps:
                        printer.cmdGetCurrentTemps();
                        break;
                    case CmdSetTempTable:
                        printer.cmdSetTempTable();
                        break;
#if defined(HASFILAMENTSENSOR) || defined(RUNFILAMENTSENSOR)
                    case CmdGetFilSensor:
                        printer.cmdGetFilSensor();
                        break;
#endif

#if 0
// Currently not used:
                    case CmdDisableStepperIsr:
                        printer.cmdDisableStepperIsr();
                        break;
#endif

#if defined(DDSim)
                    case CmdExit:
                        printf("CmdExit received, exiting...\n");
                        exit(0);
                        break;
#endif

                    case CmdSetPIDValues: {

                            ScaledUInt32 kp;
                            rxBuffer.readScaledUInt32NoCheckCobs(kp);

                            ScaledUInt32 ki;
                            rxBuffer.readScaledUInt32NoCheckCobs(ki);

                            int32_t maxEsum = rxBuffer.readInt32NoCheckCobs();

                            ScaledUInt32 kd;
                            rxBuffer.readScaledUInt32NoCheckCobs(kd);

                            ScaledUInt32 kpC;
                            rxBuffer.readScaledUInt32NoCheckCobs(kpC);

                            ScaledUInt32 kiC;
                            rxBuffer.readScaledUInt32NoCheckCobs(kiC);

                            int32_t maxEsumC = rxBuffer.readInt32NoCheckCobs();

                            ScaledUInt32 kdC;
                            rxBuffer.readScaledUInt32NoCheckCobs(kdC);

                            ScaledUInt32 kiSwitchToHeating;
                            rxBuffer.readScaledUInt32NoCheckCobs(kiSwitchToHeating);

                            ScaledUInt32 kiSwitchToCooling;
                            rxBuffer.readScaledUInt32NoCheckCobs(kiSwitchToCooling);

                            uint16_t Tu = rxBuffer.readUInt16NoCheckCobs();

                            printer.cmdSetPIDValues(
                                kp,
                                ki, maxEsum,
                                kd,
                                kpC,
                                kiC, maxEsumC,
                                kdC,
                                kiSwitchToHeating,
                                kiSwitchToCooling,
                                Tu);
                            txBuffer.sendACK();
                        }
                        break;

                    case CmdSetStepsPerMM: {
                            uint16_t spmmX = rxBuffer.readUInt16NoCheckCobs();
                            uint16_t spmmY = rxBuffer.readUInt16NoCheckCobs();
                            uint16_t spmmZ = rxBuffer.readUInt16NoCheckCobs();
                            printer.cmdSetStepsPerMM(spmmX, spmmY, spmmZ);
                            txBuffer.sendACK();
                        }
                        break;

                    case CmdSetHostSettings: {
                            HostSettings hs;
                            hs.buildVolX = rxBuffer.readUInt32NoCheckCobs();
                            hs.buildVolY = rxBuffer.readUInt32NoCheckCobs();
                            hs.buildVolZ = rxBuffer.readUInt32NoCheckCobs();
                            hs.xHomeDir = rxBuffer.readNoCheckCobs();
                            hs.yHomeDir = rxBuffer.readNoCheckCobs();
                            hs.zHomeDir = rxBuffer.readNoCheckCobs();
                            printer.cmdSetHostSettings(hs);
                            txBuffer.sendACK();
                        }
                        break;

                    case CmdSystemReset:
                        timer.startResetTimer();
                        txBuffer.sendACK();
                        break;

                    case CmdDumpMassStorage: {
                            int32_t block = rxBuffer.readInt32NoCheckCobs();
                            printer.cmdDumpMassStorage(block);
                            txBuffer.sendACK();
                        }
                        break;

                    case CmdSetIncTemp: {
                            uint8_t heater = rxBuffer.readNoCheckCobs();
                            int16_t incTemp = rxBuffer.readInt16NoCheckCobs();
                            printer.cmdSetIncTemp(heater, incTemp);
                            txBuffer.sendACK();
                        }
                        break;

                    case CmdGetFreeMem:
                        printer.cmdGetFreeMem();
                        break;

                    case CmdGetFSReadings: {
                        filamentSensor.cmdGetFSReadings(10);
                        }
                        break;

                    case CmdGetVersion:
                        printer.cmdGetVersion();
                        break;

                    default:
                        txBuffer.sendSimpleResponse(RespUnknownCommand, commandByte);
                        #if defined(HEAVYDEBUGRX)
                        bytesLeft = rxBuffer.size();
                        #endif
                }

                #if defined(HEAVYDEBUGRX)
                massert(rxBuffer.size() >= bytesLeft);
                #endif

                rxBuffer.ringBufferInit(); // clear rx buffer
            }

            PT_RESTART();
            PT_END();
        }

        // Check checksum, do errorhandling if mismatch
        bool checkCrc(uint8_t flags, uint8_t cs1, uint8_t cs2, uint16_t computedCrc) {

            // 
            //  0x1: (x, y) -> (x, y)
            //  0x2: (0, y) -> (1, y)
            //  0x3: (x, 0) -> (x, 1)
            //  0x4: (0, 0) -> (1, 1)
            // 
            switch (flags) {
                case 0x2:
                    cs2 &= ~0x1;
                    break;
                case 0x3:
                    cs1 &= ~0x1;
                    break;
                case 0x4:
                    cs1 &= ~0x1;
                    cs2 &= ~0x1;
                    break;
            }

            if ((((uint16_t)cs2<<8)|cs1) != computedCrc) {

                // printf("Checksum Error: 0x%x, computed: 0x%x\n", (cs2<<8)|cs1,  computedCrc);
                crcError();
                return false;
            }

            return true;
        }
};

// static UsbCommand usbCommand;
UsbCommand usbCommand;

#if defined(AVR)
FWINLINE
#endif
void loop() {

    TaskEnd(taskTiming, TaskIdle);

    uint32_t m = millis();

    // Timer for slow running tasks (temp, encoder)
    static uint32_t timer10mS = m + TIMER10MS;
    static uint32_t timer100mS = m + TIMER100MS;

    TaskStart(taskTiming, TaskSum);

    if (m >= timer10mS) { // Every 10 mS

        timer10mS = m + TIMER10MS;

        // Check hardware and software endstops:
        if (printer.moveType == Printer::MoveTypeNormal) {

            if (X_STOP_PIN :: active() || Y_STOP_PIN :: active() || Z_STOP_PIN :: active() 
                #if defined(DualZStepper)
                    || Z1_STOP_PIN :: active()
                #endif
                ) {

                LCDMSGKILL(RespHardwareEndstop, "", "");
                txBuffer.sendResponseStart(RespKilled);
                txBuffer.sendResponseUint8(RespHardwareEndstop);
                txBuffer.sendResponseBlob((uint8_t*)current_pos_steps, 3*sizeof(int32_t));
                txBuffer.sendResponseUint8(X_STOP_PIN :: active());
                txBuffer.sendResponseUint8(Y_STOP_PIN :: active());
                txBuffer.sendResponseUint8(Z_STOP_PIN :: active()
                    #if defined(DualZStepper)
                        || Z1_STOP_PIN :: active()
                    #endif
                    );
                txBuffer.sendResponseEnd();
                kill();
            }
            else if (X_SW_ENDSTOP_PRESSED || Y_SW_ENDSTOP_PRESSED || Z_SW_ENDSTOP_PRESSED) {

                LCDMSGKILL(RespSoftwareEndstop, "", "");
                txBuffer.sendResponseStart(RespKilled);
                txBuffer.sendResponseUint8(RespSoftwareEndstop);
                txBuffer.sendResponseBlob((uint8_t*)current_pos_steps, 3*sizeof(int32_t));
                txBuffer.sendResponseUint8(X_SW_ENDSTOP_PRESSED);
                txBuffer.sendResponseUint8(Y_SW_ENDSTOP_PRESSED);
                txBuffer.sendResponseUint8(Z_SW_ENDSTOP_PRESSED);
                txBuffer.sendResponseEnd();
                kill();
            }
        }

        //
        // Measure temperatures every 10ms
        //
        TaskStart(taskTiming, TaskTempControl);
        tempControl.Run();
        TaskEnd(taskTiming, TaskTempControl);

        // Run timer
        timer.run(m);

        // Statistics: time in stepbuffer [mS]
        if (printer.printerState == Printer::StateStart) {
            printer.minBuffer = min(stepBuffer.timeInBuffer(), printer.minBuffer);
        }
        else {
            printer.minBuffer = 255;
        }

#if defined(HASFILAMENTSENSOR) || defined(RUNFILAMENTSENSOR)
        // Read filament sensor
        TaskStart(taskTiming, TaskFilSensor);
        filamentSensor.run();
        TaskEnd(taskTiming, TaskFilSensor);
#endif
    }

    m = millis();
    if (m >= timer100mS) { // Every 100 mS

        timer100mS = m + TIMER100MS;

        //
        // Control heater 
        //
        TaskStart(taskTiming,  TaskHeater);
        tempControl.heater();
        TaskEnd(taskTiming,  TaskHeater);

        // Dont pollute process info with blocking task
        TaskPause(taskTiming, TaskSum);
        printer.runErase();
        TaskContinue(taskTiming, TaskSum);

        printer.checkPrintFinished();

        //
        // Turn on/off hotend fan
        //
        printer.runHotEndFan();

#if defined(POWER_BUTTON)
        printer.checkPowerOff(m);
#endif
    }

    // If printing, then read stepper data from mass storage and push it to
    // the stepper buffer.
    TaskStart(taskTiming, TaskFillBuffer);
    fillBufferTask.Run();
    TaskEnd(taskTiming, TaskFillBuffer);

    // Handle USB output
    TaskStart(taskTiming, TaskUsbOutput);
    txBuffer.Run();
    TaskEnd(taskTiming, TaskUsbOutput);

    // Handle USB input
    // m = millis();

    TaskStart(taskTiming, TaskUsbInput);
    usbCommand.Run();
    TaskEnd(taskTiming, TaskUsbInput);

    // massert((millis()-m) < 20);

    // Write stepper data to mass storage
    TaskStart(taskTiming, TaskSwapDev);
    swapDev.Run();
    TaskEnd(taskTiming, TaskSwapDev);

    // If printing, then read stepper data from mass storage and push it to
    // the stepper buffer.
    // TaskStart(taskTiming, TaskFillBuffer);
    // fillBufferTask.Run();
    // TaskEnd(taskTiming, TaskFillBuffer);

    TaskEnd(taskTiming, TaskSum);

    TaskStart(taskTiming, TaskIdle);
}


void printDebugInfo() {
#if defined(REPRAP_DISCOUNT_SMART_CONTROLLER)
    lcd.setCursor(0, 0); lcd.print("ser:"); lcd.print(rxBuffer.size());
    lcd.print("B:"); lcd.print(swapDev.busy());
    // lcd.print("WP:"); lcd.print(swapDev.getWritePos());

    lcd.setCursor(0, 1); lcd.print("swd:"); lcd.print(swapDev.available());

    lcd.setCursor(0, 2); lcd.print("sdr:"); lcd.print(sDReader.available());

    lcd.setCursor(0, 3); lcd.print("stb:"); lcd.print(stepBuffer.size());

    // Wait 100 s before reboot
    for (int i=0; i<100000; i++) {
        txBuffer.Run();
        WDT_RESET();
        delay(1);
    }
#endif
}

#if defined(AVR)
int main(void) {

    // Call arduino init
    init();

    setup();

    for (;;) {
        loop();
    }

    return 0;
}
#endif




